<?xml version="1.0" encoding="UTF-8"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_all.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:lim="https://dhil.lib.sfu.ca/lyoninmourning" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:sqf="http://www.schematron-quickfix.com/validator/process" xml:lang="en">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Schema and Encoding Guidelines for the <title level="m">Lyon in Mourning</title> Project</title>
            <respStmt>
               <resp>Principle Investigator</resp>
               <name>Leith Davis</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p>Probably free?</p>
         </publicationStmt>
         <sourceDesc>
            <p>No source; born digital.</p>
         </sourceDesc>
      </fileDesc>
      <encodingDesc>
         <charDecl>
            <glyph xml:id="char_star">
                <unicodeProp name="Name" value="STAR / ASTERISK"/>
                <mapping type="standard">*</mapping>
                <mapping type="unicode">U+002A</mapping>
                <figure>
                   <graphic url="img:char_star.svg"/> 
                </figure>
            </glyph>
            <glyph xml:id="char_cross">
               <unicodeProp name="Name" value="CROSS OR DAGGER"/>
               <mapping type="standard">✝</mapping>
               <mapping type="unicode">U+271D</mapping>
               <figure>
                  <graphic url="img:char_cross.svg"/>
               </figure>
            </glyph>
            <glyph xml:id="char_x">
               <unicodeProp name="Name" value="X"/>
               <mapping type="standard">X</mapping>
            </glyph>
            <glyph xml:id="char_circledX">
               <unicodeProp name="Name" value="X WITH CIRCLE"/>
               <mapping type="standard">ⓧ</mapping>
            </glyph>
            <glyph xml:id="char_phi">
               <unicodeProp name="Name" value="PHI"/>
               <mapping type="standard">φ</mapping>
               <mapping type="unicode">U+03C6</mapping>
            </glyph>
            <glyph xml:id="char_theta">
               <unicodeProp name="Name" value="THETA"/>
               <mapping type="standard">θ</mapping>
               <mapping type="unicode">U+03B8;</mapping>
            </glyph>
            <glyph xml:id="char_umbrella">
               <unicodeProp name="Name" value="UMBRELLA"/>
               <mapping type="standard">☂</mapping>
               <figure>
                  <graphic url="img:char_umbrella.svg"/>
               </figure>
            </glyph>
            <glyph xml:id="char_tau">
               <unicodeProp name="Name" value="TAU"/>
               <mapping type="standard">Τ</mapping>
            </glyph>
            <glyph xml:id="char_pi">
               <unicodeProp name="Name" value="PI"/>
               <mapping type="standard">Π</mapping>
            </glyph>
            <glyph xml:id="char_UNKNOWN">
               <unicodeProp name="Name" value="UNKNOWN"/>
               <desc>An unknown character to be used as a placeholder until
               a character can be properly assigned.</desc>
            </glyph>
         </charDecl>
         <classDecl>
            <taxonomy>
               <desc>Genre</desc>
               <category xml:id="letter">
                  <catDesc>
                     <term>letter</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="speech">
                  <catDesc>
                     <term>speech</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="conversation">
                  <catDesc>
                     <term>conversation</term>
                  </catDesc>
               </category>
               <category xml:id="accountNarrative">
                  <catDesc>
                     <term>account/narrative</term>
                  </catDesc>
               </category>
               <category xml:id="text">
                  <catDesc>
                     <term>text</term>
                  </catDesc>
                  <category xml:id="text_poem">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_song">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_epitaph">
                     <catDesc>
                        <term>epitaph</term>
                     </catDesc>
                  </category>
               </category>
               <category xml:id="insert">
                  <catDesc>
                     <term>insert</term>
                  </catDesc>
               </category>
               <category xml:id="misc">
                  <catDesc>
                     <term>Miscellaneous</term>
                  </catDesc>
               </category>
            </taxonomy>
            <taxonomy xml:id="docStatus">
               <bibl>Document Status taxonomy</bibl>
               <category xml:id="docStatus_empty">
                  <catDesc>
                     <term>empty</term>
                     <gloss>empty / not yet worked on or edited</gloss>
                  </catDesc>
                  <category xml:id="docStatus_inProgress">
                     <catDesc>
                        <term>in progress</term>
                        <gloss>currently being worked on, but not yet "done"</gloss>
                     </catDesc>
                  </category>
                  <category xml:id="docStatus_readyForProof">
                     <catDesc>
                        <term>ready for proof</term>
                        <gloss>corrected and encoded, and is now ready to be proofed</gloss>
                     </catDesc>
                  </category>
                  <category xml:id="docStatus_proofed">
                     <catDesc>
                        <term>proofed</term>
                        <gloss>proofed and checked</gloss>
                     </catDesc>
                  </category>
               </category>
            </taxonomy>
         </classDecl>

         <tagsDecl>
            <!--HOW THIS WORKS:
               @xml:id = the rendition pointer,
               desc / gloss = the desc and gloss in the ODD
               outputRendition = the CSS styling-->
            <rendition xml:id="rnd_super">
               <desc>Superscript</desc>
               <gloss>Superscripted letters</gloss>
               <outputRendition>text-align:super;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_sub">
               <desc>Subscript</desc>
               <gloss>Subscripted letters</gloss>
               <outputRendition>text-align:sub;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_underlined">
               <desc>Underlined</desc>
               <gloss>Items that are underlined; note that since underlining often denotes
               emphasis, this should usually be used with more precise elements (persName, emph, etc)</gloss>
               <outputRendition>text-decoration:underline;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_right-braced">
               <desc>Right braced</desc>
               <gloss>A set of elements with a CURLY right brace</gloss>
            </rendition>
            <rendition xml:id="rnd_bordered-all">
               <desc>Bordered on all four sides</desc>
               <gloss>Items that have a full border</gloss>
               <outputRendition>border:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-left">
               <desc>Left bordered</desc>
               <gloss>Items that have a left border (straight or ragged)</gloss>
               <outputRendition>border-left:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-right">
               <desc>Right bordered</desc>
               <gloss>An element with a right border (straight or ragged)</gloss>
               <outputRendition>border-right:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-bottom">
               <desc>Bottom bordered</desc>
               <gloss>An element with a bottom border (straight or ragged)</gloss>
               <outputRendition>border-bottom:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-bottom-dashed">
               <desc>Bottom bordered</desc>
               <gloss>An element with a dashed bottom border</gloss>
               <outputRendition>border-bottom:1px dashed black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bordered-top">
               <desc>Top bordered</desc>
               <gloss>An element with a bottom border (straight or ragged)</gloss>
               <outputRendition>border-top:1px solid black;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_bold">
               <desc>Bold</desc>
               <gloss>Bold or heavier weight. TODO: What is the difference between
               bold and a shift in ink?</gloss>
               <outputRendition>font-weight:bold;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_indent-first-line">
               <desc>Indent</desc>
               <gloss>A paragraph or poetic line that has a first line indent.</gloss>
               <outputRendition>text-indent: 1rem;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_indent-block">
               <desc>Indented block</desc>
               <gloss>A block element that is entirely indented (i.e. a paragraph). Use the @n attribute as a multiplier.</gloss>
               <outputRendition>margin-left: 1rem;</outputRendition>
            </rendition>
            
            <rendition xml:id="rnd_overline">
               <desc>Overline</desc>
               <gloss>An element with a line above. Note: this should NOT be used for letters with macrons (i.e. ō);
                  if those ever appear, use the actual letter.</gloss>
               <outputRendition>text-decoration: overline;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_small">
               <desc>Small text</desc>
               <gloss>Use for marginal notes etc, if they are smaller</gloss>
               <outputRendition>font-size: 0.8em;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_large" select="head">
               <desc>Larger text (i.e. headings)</desc>
               <gloss>Use this for headings or other large text</gloss>
               <outputRendition>font-size: 1.5rem;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_strikethrough" selector="del">
               <desc>Strikethrough</desc>
               <gloss>Use this for text that is struck through; note that,
               by default, you do not need to put this element for dels.</gloss>
               <outputRendition>text-decoration:line-through;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_normal">
               <desc>Normal</desc>
               <gloss>This text should NOT follow any of the default assumptions
               about its styling (i.e. a heading that is NOT large; a deletion that is
               not struck through)</gloss>
            </rendition>
            <rendition xml:id="rnd_left">
               <desc>Left aligned</desc>
               <gloss>Left aligned text</gloss>
               <outputRendition>text-align: left;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_right">
               <desc>Right aligned</desc>
               <gloss>Left aligned text</gloss>
               <outputRendition>text-align: right;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_center">
               <desc>Centered</desc>
               <gloss>Centered text</gloss>
               <outputRendition>text-align: center;</outputRendition>
            </rendition>
            <rendition xml:id="rnd_embellished">
               <desc>Embellished letter</desc>
               <gloss>Use this when some letter/character is embellished.</gloss>
            </rendition>
            <rendition xml:id="rnd_two-column">
               <desc>A block that has two columns</desc>
               <gloss>Used for instances where (usually a closer) has two distinct
               blocks with something in the left and right-column</gloss>
            </rendition>
            <rendition xml:id="rnd_rotate-left">
               <desc>A block rotated -90 degrees.</desc>
               <gloss>Used for notes, annotations, et cetera that are rotated -90 degrees (i.e.
               read from bottom to top)</gloss>
               <outputRendition>transform: rotate(-90deg);</outputRendition>
            </rendition>
            <rendition xml:id="rnd_rotate-right">
               <desc>A block rotated 90 degrees.</desc>
               <gloss>Used for notes, annotations, et cetera that are rotated 90 degrees (i.e.
               read from top to bottom)</gloss>
               <outputRendition>transform: rotate(90deg);</outputRendition>
            </rendition>
         </tagsDecl>
         <listPrefixDef>
            <prefixDef ident="doc" matchPattern="(.+)(#.+)?" replacementPattern="$1.xml$2">
               <p>Mechanism for pointing to a document in the repository. E.g. <val>doc:vol11_vol1</val>.</p>
            </prefixDef>
            <prefixDef ident="islandora" matchPattern="(\d+)" replacementPattern="https://digital.lib.sfu.ca/islandora/object/lyoninmourning:$1">
               <p>Resolves links to SFU's Islandora collection for the Lyon in Mourning page images.</p>
            </prefixDef>
            <prefixDef ident="lib" matchPattern="(\d+)" replacementPattern="#sfu_pg_$1">
               <p>Resolves links from a page in a volume to a facsimile element.</p>
            </prefixDef>
            <prefixDef ident="lim" matchPattern="(.+)" replacementPattern="lim.odd#$1"/>
            <prefixDef ident="prs" matchPattern="(.+)" replacementPattern="people.xml#$1">
               <p>Resolves links to a person to the personography.</p>
            </prefixDef>
            <prefixDef ident="plc" matchPattern="(.+)" replacementPattern="places.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="team" matchPattern="(.+)" replacementPattern="contributors.xml#$1">
               <p>Resolve links to team members.</p>
            </prefixDef>
            <prefixDef ident="org" matchPattern="(.+)" replacementPattern="organizations.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="obj" matchPattern="(.+)" replacementPattern="objects.xml#$1">
               <p>Resolves links to an object to the object database.</p>
            </prefixDef>
            <prefixDef ident="bibl" matchPattern="(.+)" replacementPattern="bibliography.xml$1">
               <p>Resolves links to a bibliographic item.</p>
            </prefixDef>
            <prefixDef ident="img" matchPattern="(.+)" replacementPattern="images/$1"/>
            <prefixDef ident="g" matchPattern="(.+)" replacementPattern="lim.odd#char_$1">
               <p>Resolves links to a glyph.</p>
            </prefixDef>
            <prefixDef ident="hand" matchPattern="(.+)" replacementPattern="lim.odd#hand_$1">
               <p>Resolves link to a particular hand.</p>
            </prefixDef>
         </listPrefixDef>
      </encodingDesc>
      <profileDesc>
         <particDesc>
            <listPerson>
               <person xml:id="Forbes">
                  <persName>Forbes</persName>
               </person>
               <person xml:id="Chambers">
                  <persName>Chambers</persName>
               </person>
            </listPerson>
         </particDesc>
         <handNotes>
            <handNote xml:id="hand_Forbes" medium="ink" scope="major" scribeRef="#Forbes">Forbes' hand</handNote>
            <handNote xml:id="hand_Chambers" medium="pencil" scope="minor" scribeRef="#Chambers">Chambers' hand, written in pencil</handNote>
            <handNote xml:id="hand_unknown">An unknown hand that is neither Chambers or Forbes.</handNote>
         </handNotes>
      </profileDesc>
   </teiHeader>
   <text>
      <front>
         <div>
            <head>Lyon in Mourning Encoding Guidelines</head>
            <p>This is the encoding documentation for the forthcoming <ref target="https://dhil.lib.sfu.ca/lyoninmourning">Lyon in Mourning digital edition</ref>, which is part of the larger SSHRC-funded Networking Jacobites project (Leith Davis [SFU, Department of English], Ralph MacLean [National Library of Scotland], and Joey Takeda [SFU, Digital Humanities Innovation Lab]).</p>
         </div>
      </front>
      <body>
         <div>
            <divGen xml:id="index"/>
         </div>
      </body>
      <back>
         <div>
            <head>Appendix</head>
            <schemaSpec ident="lim" start="TEI div person place org biblStruct" source="tei:4.7.0">

               <moduleRef key="analysis" include="pc w"/><elementSpec ident="pc" mode="change" module="analysis">
            <!--Remove all other attributes-->
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.segLike" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <content>
                     <textNode/>
                  </content>
                  <constraintSpec ident="pc.onlyPunct" scheme="schematron" mode="add">
                     <desc>Only punctuation in pc.</desc>
                     <constraint>
                        <sch:rule context="tei:pc">
                           <sch:assert test="matches(text(),'^[\p{P}=]$')">ERROR: Only a single punctuation character is allowed in pc</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="dash.shouldBeInWord" scheme="schematron" mode="add">
                     <desc>Only punctuation in pc.</desc>
                     <constraint>
                        <sch:rule context="tei:pc[text() = '-'][@force='weak'][ancestor::tei:TEI/descendant::tei:revisionDesc/@docStatus='inProgress']">
                           <sch:assert test="ancestor::tei:w">ERROR: All end of line hyphens must be contained by the word (&lt;w&gt;) element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" mode="delete"/>
                     <attDef ident="pre" mode="delete"/>
                     <attDef ident="force" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="w" mode="change" module="analysis">
                  <classes mode="change">
                     <memberOf key="att.segLike" mode="delete"/>
                     <memberOf key="att.fragmentable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <constraintSpec ident="w.shouldContainPC" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w[not(@part)]">
                           <sch:assert test="descendant::tei:pc[@force='weak'] and descendant::tei:lb">ERROR: Word elements must include a pc and an lb,
                              since the element should only be used to flag words separated across line boundaries </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="w.shouldBeInParts" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w">
                           <sch:assert test="not(descendant::tei:fw or descendant::tei:pb)">ERROR: Do not include formeworks or page beginnings in a word element; if a word is split across pages, then use the @part attribute to signal the initial and final parts of the word. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="w.partsShouldMatch" scheme="schematron" mode="add">
                     <desc>Words should always contain a pc</desc>
                     <constraint>
                        <sch:rule context="tei:w">
                           <sch:let name="text" value="string-join(descendant::text(),'')"/>
                           <sch:assert test="not(matches($text,'^\s|\s$'))">ERROR: <sch:name/> should begin or end with spaces.</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:text[descendant::tei:w[@part]]">
                           <sch:assert test="count(descendant::tei:w[@part]) mod 2 = 0">ERROR: Odd number of split words found in this transcription.</sch:assert>
                           
                        </sch:rule>
                        <sch:rule context="tei:w[@part = 'F']">

                           <sch:assert test="preceding-sibling::tei:w[1][@part = 'I']">ERROR: Initial word part missing following final part.</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:w[@part = 'I']">
                           
                           <sch:assert test="following-sibling::tei:w[1][@part = 'F']">ERROR: Final word part missing preceding initial part. </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><classSpec ident="att.linguistic" module="analysis" type="atts" mode="delete"/>
               <moduleRef key="core" include="abbr add author bibl biblStruct choice cit corr date del desc divGen editor ellipsis emph expan foreign gap gloss graphic head hi imprint item l label lb lg list listBibl mentioned milestone name note noteGrp num orig p pb ptr pubPlace publisher q quote ref reg resp respStmt rs sic term time title unclear"/><elementSpec ident="abbr" module="core" mode="change">
                  <classes mode="change">
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <constraintSpec ident="abbr.shouldntContainJustAmp" scheme="schematron" mode="add">
                     <desc>Don't expand the ampersand only.</desc>
                     <constraint>
                        <sch:rule context="tei:abbr">
                           <sch:let name="content" value="string(.)"/>
                           <sch:assert test="not(matches($content, '^\s*&amp;\s*$'))">ERROR: There is no need to tag ampersands when it means "and".</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="abbr.typeCheck" scheme="schematron" mode="add">
                     <desc>Type is required when not in choice</desc>
                     <constraint>
                        <sch:pattern>
                           <!--TODO: Remove @ref once feasible-->
                           <sch:rule context="tei:choice/tei:abbr">
                              <sch:assert test="not(@type)">ERROR: Do not put a type attribute on abbrs in choice.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:abbr[not(parent::tei:choice)]">
                              <sch:assert test="@type">ERROR: @type is required when abbr is not in a choice.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef mode="change" ident="type">
                        <valList mode="replace" type="closed">
                           <valItem ident="another" mode="add">
                              <desc>anoyr</desc>
                              <gloss>Abbreviation for <mentioned>another</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="Brother" mode="add">
                              <desc>Broyr</desc>
                              <gloss>Abbreviation for <mentioned>Brother</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="which" mode="add">
                              <desc>qch</desc>
                              <gloss>Abbreviation for <mentioned>which</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="whom" mode="add">
                              <desc>qm</desc>
                              <gloss>Abbreviation for <mentioned>whom</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="when" mode="add">
                              <desc>qn</desc>
                              <gloss>Abbreviation for <mentioned>when</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="who" mode="add">
                              <desc>qo</desc>
                              <gloss>Abbreviation for <mentioned>who</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="what" mode="add">
                              <desc>qt</desc>
                              <gloss>Abbreviation for <mentioned>what</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="with" mode="add">
                              <desc>wt</desc>
                              <gloss>Abbreviation for <mentioned>with</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="the" mode="add">
                              <desc>ye</desc>
                              <gloss>Abbreviation for <mentioned>the</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="then" mode="add">
                              <desc>yn</desc>
                              <gloss>Abbreviation for <mentioned>then</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="your" mode="add">
                              <desc>yr</desc>
                              <gloss>Abbreviation for <mentioned>your</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="that" mode="add">
                              <desc>yt</desc>
                              <gloss>Abbreviation for <mentioned>that</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="them" mode="add">
                              <desc>ym</desc>
                              <gloss>Abbreviation for <mentioned>them</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="there" mode="add">
                              <desc>yre</desc>
                              <gloss>Abbreviation for <mentioned>there</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="this" mode="add">
                              <desc>ys</desc>
                              <gloss>Abbreviation for <mentioned>this</mentioned>
                              </gloss>
                           </valItem>
                           <valItem ident="fm" mode="add">
                              <desc>fm</desc>
                              <gloss>Abbreviation for <mentioned>from</mentioned></gloss>
                           </valItem>
                           <valItem ident="qre" mode="add">
                              <desc>qre</desc>
                              <gloss>Abbreviation for <mentioned>where</mentioned></gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="add" module="core" mode="change">
                  <classes mode="change">
                     <!--We've deleted att.editLike, so 
                        we must add att.written -->
                     <memberOf key="att.written" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="bibl" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.docStatus" mode="delete"/>
                  </classes>
               </elementSpec><elementSpec ident="corr" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.transcriptional, since it should only be in <choice>-->
                     <memberOf key="model.pPart.transcriptional" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="date" module="core" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.dateLike" mode="add"/>
                     <memberOf key="model.publicationStmtPart.detail"/>
                     <memberOf key="att.datable.w3c" mode="add"/>
                     <memberOf key="att.global.rendition" mode="add"/>
                  </classes>
                  
               </elementSpec><elementSpec ident="del" module="core" mode="change">
                  <classes mode="change">
                     <!--We've deleted att.editLike, so 
                        we must add att.written -->
                     <memberOf key="att.written" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="ellipsis" module="core" mode="change">
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        He said, in the Event of a R<ellipsis>
                           <metamark><space/></metamark>
                           <supplied resp="team:JT1">estoration</supplied>
                        </ellipsis>,
                     </egXML>
                  </exemplum>
                  <exemplum>
                     <egXML xmlns="http://www.tei-c.org/ns/Examples">
                        If The P<ellipsis>
                           <metamark><space/></metamark>
                           <choice>
                              <seg>rince</seg>
                              <seg>retender</seg>
                           </choice>
                        </ellipsis> returns...
                     </egXML>
                  </exemplum>
                  
               </elementSpec><elementSpec ident="expan" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.editorial, since it should only be in <choice>-->
                     <memberOf key="model.pPart.editorial" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="head" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="head.bdHidden">
                     <constraint>
                        <sch:rule context="tei:head[matches(@rendition,'rnd:hidden')]">
                           <sch:assert test="$isBornDigital">ERROR: Only use rnd:hidden in born digital documents.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="rendition" mode="change">
                        <valList type="closed" mode="change">
                           <valItem mode="add" ident="rnd:hidden">
                              <gloss>hidden</gloss>
                              <desc>A heading that is
                                 hidden (for accessibility purposes).</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="item" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="l" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="lb" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.facs" mode="add"/>
                     <memberOf key="att.spanning" mode="delete"/>
                  </classes>
                  <!--                  <constraintSpec ident="lb.noSpaces" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:lb[preceding-sibling::node()[1][self::tei:pc]]">
                           <sch:assert test="matches(following::text()[1],'^\S')">ERROR: All punctuation separated words in lines should not have any spaces after the line beginning element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>-->
                  <constraintSpec ident="lb.shouldUseDecimal" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:lb[@facs]">
                           <sch:assert test="matches(@facs,'(lib|pg):\d+\.\d+')">ERROR: lb elements with facs must specify the line in the form lib:#.lineNum or pg:#.lineNum (e.g. lib:23.2)</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="list" module="core" mode="change">
                  <constraintSpec scheme="schematron" ident="list.bornDigitalNeedsRendition">
                     <constraint>
                        <sch:rule context="tei:list[not(@rendition)]">
                           <sch:assert test="not($isBornDigital)">ERROR: All lists in born digital document require the rendition attribute.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="rendition" mode="change">
                        <valList type="closed" mode="change">
                           <valItem mode="add" ident="rnd:list_ordered">
                              <desc>An ordered list</desc>
                           </valItem>
                           <valItem mode="add" ident="rnd:list_unordered">
                              <desc>An unordered list</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="milestone" module="core" mode="change">
                  <constraintSpec ident="milestone.sectionInBody" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone[@unit='section']">
                              <sch:assert test="ancestor::tei:body">ERROR: Section milestones should be within the body of the text</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="milestone.itemInText" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone[@unit='item']">
                              <sch:assert test="ancestor::tei:text and preceding-sibling::tei:body">ERROR: Item milestones should only occur at the end of the item after the closing body tag.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" mode="change">
                        <valList type="semi" mode="replace">
                           <valItem ident="section" mode="add">
                              <gloss>section</gloss>
                              <desc>A horizontal rule representing a shift in section</desc>
                           </valItem>
                           <valItem ident="item" mode="add">
                              <gloss>item</gloss>
                              <desc>A horizontal rule representing the end of an item</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="name" module="core" mode="change">
                  <constraintSpec ident="name.notForPeopleOrPlaces" mode="change" scheme="schematron">
                     <desc>Name should only be used if there isn't a more specific element.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:name[@ref]">
                           <sch:assert test="not(matches(@ref,'^prs:'))">ERROR: Use &lt;persName&gt; to tag names of people.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^plc:'))">ERROR: Use &lt;placeName&gt; to tag names of places.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^org:'))">ERROR: Use &lt;orgName&gt; to tag names of organizations.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="opt">
                        <valList type="closed" mode="add">
                           <valItem ident="event" mode="add">
                              <gloss>event</gloss>
                              <desc>The name of an event (e.g. "The Battle of Prestonpans")</desc>
                           </valItem>
                           <valItem ident="object" mode="add">
                              <gloss>object</gloss>
                              <desc>The name of an object (e.g. "Excalibur")</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="note" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <content>
                     <alternate>
                        <sequence>
                           <sequence preserveOrder="false">
                              <elementRef key="supplied" minOccurs="0" maxOccurs="unbounded"/>
                              <elementRef key="noteMarker" minOccurs="0" maxOccurs="unbounded"/>
                           </sequence>
                           <alternate>
                              <sequence>
                                 <elementRef key="p" minOccurs="1" maxOccurs="unbounded"/>
                                 <elementRef key="closer" minOccurs="0"/>
                              </sequence>
                              <elementRef key="NB" minOccurs="1" maxOccurs="1"/>
                           </alternate>
                        </sequence>
                        <macroRef key="macro.specialPara"/>
                     </alternate>
                  </content>
                  <constraintSpec ident="note.mustHaveTypeInText" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[ancestor::tei:text][not(ancestor::tei:div[@type='footnotes'])]">
                              <sch:assert test="@type">ERROR: All notes in transcriptions must have a @type.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="note.coOccurenceConstraints" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type='editorial']">
                              <sch:assert test="@resp">ERROR: All editorial notes must have a @resp</sch:assert>
                              <sch:assert test="not(@anchored)">ERROR: Do not use @anchored for editorial notes</sch:assert>
                              <sch:assert test="not(@hand)">ERROR: Do not use @hand for editorial notes.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@type='lim']">
                              <sch:assert test="not(@resp)">ERROR: Do not use @resp on LiM notes. Use @hand instead.</sch:assert>
                              <sch:assert test="every $text in text() satisfies not(matches($text,'\S'))">ERROR: All lim notes
                              must have structured context (i.e. 0 or more noteMarkers, either a sequence of paragraphs and a closer OR an NB) </sch:assert>
                              <sch:assert test="@anchored">ERROR: All LiM notes must specify whether it is anchored using the @anchored attribute.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@type='lim']/tei:supplied">
                              <sch:assert test="tei:noteMarker">ERROR: Supplied as a direct child of note must contain a noteMarkers.</sch:assert>
                              <sch:assert test="empty(tei:*[not(self::tei:noteMarker)])">ERROR: Only noteMarkers are allowed within note[@type='lim']/supplied.</sch:assert>
                              <sch:assert test="every $text in text() satisfies not(matches($text,'\S'))">ERROR: Do not put text within the supplied in a noteMarker.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="note.unknownsShouldBeFixed" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type = 'unknown']">
                              <sch:assert test="//tei:revisionDesc[@docStatus=('empty','uneditedTranscription')]">WARNING: Unknown notes should be replaced by either
                                 the appropriate encoding (usually supplied, gap, del, etc) or should become a @type='editorial'.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="anchoredNotesShouldUseNoteMarker" scheme="schematron">
                     <desc>Anchored notes should have a child noteMarker</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@anchored='true']">
                              <sch:assert test="tei:noteMarker or tei:supplied/tei:noteMarker">ERROR: Anchored notes must
                                 contain a noteMarker element that points to the id of the
                                 note marker in the body of the text.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:note[@anchored='false']">
                              <sch:assert test="@place">ERROR: Unanchored notes must have a @place value
                                 specifying where it is on the page.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" usage="rec" mode="change">
                        <valList type="semi" mode="add">
                           <valItem ident="editorial" mode="add">
                              <gloss>editorial note</gloss>
                              <desc>An editorial note written by a team member.</desc>
                           </valItem>
                           <valItem ident="lim" mode="add">
                              <gloss>Forbes note</gloss>
                              <desc>A note that appears in the manuscript (left by Forbes or someone else).</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
                  
                  <!--<attList>
                     <!-\-Now we need the note have a choice of attributes:
                     If there's a type and its one of the three special types that
                     require attributes, then do that-\->
                     <attList org="choice">
                        <!-\-If it's a type not listed below,
                        then it shouldn't have any other attributes-\->
                        <attList org="group">
                           <attDef ident="type" usage="opt">
                              <datatype>
                                 <dataRef key="teidata.enumerated"/>
                              </datatype>
                           </attDef>
                        </attList>
                        <!-\-Group 2: An editorial note,
                        which must include @resp-\->
                        <attList org="group">
                           <attDef ident="type" usage="req">
                              <valList type="closed">
                                
                              </valList>
                           </attDef>
                           <!-\-Since we use notes in the teiHeader,
                              we have to make the use of resp required via schematron-\->
                           <attDef ident="resp" usage="req">
                              <gloss versionDate="2009-11-02" xml:lang="en">responsible party</gloss>
                              <datatype maxOccurs="unbounded">
                                 <dataRef key="teidata.pointer"/>
                              </datatype>
                              <constraintSpec ident="note.editorial.requiresResp" scheme="schematron">
                                 <constraint>
                                    <sch:rule context="tei:note[@type='editorial'][not(root(.)/*[matches(@xml:id,'vol11')])]">
                                       <sch:assert test="@resp">ERROR: All editorial notes must point to a team member.</sch:assert>
                                    </sch:rule>
                                 </constraint>
                              </constraintSpec>
                              <remarks>
                                 <p>All editorial notes must include a resp in order to identify
                                    the encoder responsible.</p>
                              </remarks>
                           </attDef>
                        </attList>
                        <!-\-Group 3: A LiM Note,
                        which is a primary source note-\->
                        <attList org="group">
                           <attDef ident="type" usage="req">
                              <valList type="closed">
                                
                              </valList>
                           </attDef>
                           <!-\-Optional hand attribute on lim notes-\->
                           <attDef ident="hand" usage="opt">
                              <desc>points to a <gi>handNote</gi> element describing the hand considered responsible for the
                                 content of the element concerned.</desc>
                              <datatype>
                                 <dataRef key="teidata.pointer"/>
                              </datatype>
                           </attDef>
                           <!-\-Sub-group:
                              if anchored is true, then it needs an @n-\->
                           <attList org="choice">
                              <attList org="group">
                                 <attDef ident="anchored" usage="req">
                                    <gloss>anchored</gloss>
                                    <desc>indicates whether the copy text shows the exact place of reference for the note.</desc>
                                    <valList type="closed">
                                       <valItem ident="true">
                                          <gloss>true</gloss>
                                          <desc>The note is anchored (i.e. it contains a symbol that anchors it in place)</desc>
                                       </valItem>
                                    </valList>
                                 </attDef>
                              </attList>
                              <attList org="group">
                                 <attDef ident="anchored" usage="req">
                                    <gloss>anchored</gloss>
                                    <desc>indicates whether the copy text shows the exact place of reference for the note.</desc>
                                    <valList type="closed">
                                       <valItem ident="false">
                                          <gloss>false</gloss>
                                          <desc>The note is not anchored (i.e. it does not contain a symbol that anchors it in place)</desc>
                                       </valItem>
                                    </valList>
                                 </attDef>
                                 <attDef ident="place" usage="req">
                                    <desc versionDate="2012-10-07" xml:lang="en">specifies where this item is placed.</desc>
                                    <datatype>
                                       <dataRef key="limdata.placement"/>
                                    </datatype>
                                    <constraintSpec ident="note.lim.requiresPlace" scheme="schematron">
                                       <constraint>
                                          <sch:rule context="tei:note[@type='lim']">
                                             <sch:assert test="@place">ERROR: All lim notes require a @place attribute to describe
                                                where on the page the original note is placed.</sch:assert>
                                          </sch:rule>
                                       </constraint>
                                    </constraintSpec>
                                 </attDef>
                              </attList>
                           </attList>
                        </attList>
                     </attList>
                  </attList>-->
               </elementSpec><elementSpec ident="noteGrp" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="lim.att.boolean" mode="add"/>
                  </classes>
                  <content>
                     <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="p" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.analytic" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="pb" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.facs" mode="add"/>
                  </classes>
                  <constraintSpec ident="pb.noDecimal" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:pb[@facs]">
                           <sch:assert test="matches(@facs,'^(lib|pg):\d+$')">ERROR: pb/@facs should be either the Forbes page number (i.e. pg:233 for the page Forbes numbers as 233) or via the page number in the library catalogue using the lib scheme (i.e. lib:22).</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="pb.unique" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:pb[@facs][not(ancestor::tei:TEI[@xml:id = 'vol11'])]">
                           <sch:let name="facsPtr" value="@facs"/>
                           <sch:let name="allFacs" value="//tei:pb[@facs]"/>
                           <sch:assert test="count($allFacs[contains-token(@facs, $facsPtr)]) = 1">
                              ERROR: Duplicate page beginning: <sch:value-of select="$facsPtr"/>
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                <!--Make @facs required-->
                     <attDef ident="facs" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="q" module="core" mode="replace">
                  <gloss versionDate="2012-03-26" xml:lang="en">quoted</gloss>
                  <desc versionDate="2012-03-26" xml:lang="en">contains material which is distinguished from the
                     surrounding text using quotation marks or a similar method, for any one of a variety of reasons including, but not limited to: direct
                     speech or thought, technical terms or jargon, authorial distance, quotations from elsewhere, and
                     passages that are mentioned but not used.</desc>
                  <classes>
                     <memberOf key="model.hiLike"/>
                     <memberOf key="model.common"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
                  <!--               <constraintSpec ident="allQuotationMarksShouldBeInQ" scheme="schematron">
                        <desc>Quotation marks must be in q elements.</desc>
                        <constraint>
                           <sch:rule context="tei:*[ancestor::tei:text]
                              [ancestor::tei:TEI/descendant::tei:limItem]
                              [ancestor::tei:TEI/descendant::tei:revisionDesc/@docStatus='inProgress']
                              [not(ancestor-or-self::tei:q)]
                              [some $text in text() satisfies matches($text,'\S')]">
                              <sch:let name="marksRex" value="'[' || codepoints-to-string(34) || '“”]'"/>
                              <sch:let name="string" value="string-join(text(),'')"/>
                              <sch:assert test="not(matches($string, $marksRex))">ERROR: All quotation marks must be contained at some point by a q element.</sch:assert>
                           </sch:rule>
                        </constraint>
                  </constraintSpec>-->
                  <attList org="choice">
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="1" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed">
                              <valItem ident="speech">
                                 <gloss>speech</gloss>
                                 <desc>Representation of speech</desc>
                              </valItem>
                           </valList>
                        </attDef>
                        <attDef ident="who" mode="add" usage="opt">
                           <desc versionDate="2005-11-05" xml:lang="en">indicates the person, or group of people, to whom the element content is ascribed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhom" mode="add" usage="opt">
                           <desc versionDate="2018-07-19" xml:lang="en">indicates the person, or group of people, to whom a speech act or action is directed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                     </attList>
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="0" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed" mode="replace">
                              <valItem ident="letter" mode="add">
                                 <gloss>letter</gloss>
                                 <desc>Representation of writing (i.e. a letter)</desc>
                              </valItem>
                           </valList>
                        </attDef>
                        <attDef ident="who" mode="add" usage="opt">
                           <desc versionDate="2005-11-05" xml:lang="en">indicates the person, or group of people, to whom the element content is ascribed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhom" mode="add" usage="opt">
                           <desc versionDate="2018-07-19" xml:lang="en">indicates the person, or group of people, to whom a speech act or action is directed.</desc>
                           <datatype maxOccurs="unbounded">
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="where" mode="add" usage="opt">
                           <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                           <datatype>
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                        <attDef ident="toWhere" mode="add" usage="opt">
                           <desc>indicates the location of something being sent.</desc>
                           <datatype>
                              <dataRef key="teidata.pointer"/>
                           </datatype>
                        </attDef>
                     </attList>
                     <attList org="group">
                        <attDef ident="type" usage="opt" mode="replace">
                           <datatype minOccurs="0" maxOccurs="1">
                              <dataRef key="teidata.enumerated"/>
                           </datatype>
                           <valList type="closed" mode="replace">
                              <valItem ident="quotation" mode="add">
                                 <gloss>quotation</gloss>
                                 <desc>Represents some sort of other quotation</desc>
                              </valItem>
                           </valList>
                        </attDef>
                     </attList>
                  </attList>
               </elementSpec><elementSpec ident="quote" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.citing"/>
                  </classes>
               </elementSpec><elementSpec ident="rs" module="core" mode="change">
                  <constraintSpec ident="rs.familyNoRef" mode="change" scheme="schematron">
                     <desc>Family references should not have a ref.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:rs[@type='family']">
                           <sch:assert test="not(@ref)">ERROR: Do not use a @ref attribute on for a family reference since it can't point to anything.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="change">
                           <valItem mode="add" ident="person">
                              <gloss>person</gloss>
                              <desc>An indirect reference to a person (e.g. "his father"); use &lt;persName&gt; for direct references (i.e. "John Smith").</desc>
                           </valItem>
                           <valItem mode="add" ident="event">
                              <gloss>event</gloss>
                              <desc>An indirect reference to an event (e.g. "the day"); use &lt;name type="event"&gt; for direct references to events.</desc>
                           </valItem>
                           <valItem mode="add" ident="place">
                              <gloss>place</gloss>
                              <desc>An indirect reference to a place (e.g. "over there"); use &lt;placeName&gt; for direct references to places (i.e. "Edinburgh").</desc>
                           </valItem>
                           <valItem mode="add" ident="object">
                              <gloss>object</gloss>
                              <desc>An indirect reference to an object (e.g. "that thing"); use &lt;name type="object"&gt; for direct references to objects (i.e. "Excalibur").</desc>
                           </valItem>
                           <valItem mode="add" ident="family">
                              <gloss>family</gloss>
                              <desc>An reference to a family (e.g. "To my family").</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="sic" module="core" mode="change">
                  <classes mode="change">
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="time" module="core" mode="change">
                  <classes mode="replace">
                      <memberOf key="att.global.rendition" mode="add"/>
                      <memberOf key="att.datable.w3c" mode="add"/>
                      <memberOf key="att.duration.w3c" mode="add"/>
                      <memberOf key="model.dateLike" mode="add"/>
                  </classes>
                  <constraintSpec ident="time.shouldHaveTextInText" scheme="schematron">
                     <desc>The <gi>time</gi> element should contain text</desc>
                     <constraint>
                        <sch:rule context="tei:time[ancestor::tei:text]">
                           <sch:assert test="normalize-space(string-join(descendant::text(),'')) ne ''">
                              ERROR: The time element should not be empty.
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="corpus" include="activity creation setting settingDesc"/><elementSpec ident="setting" module="corpus" mode="change">
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:setting[ancestor::tei:limItem[matches(@type,'speech')]]">
                              <sch:assert test="tei:scaffold">ERROR: All speeches must have a scaffold element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="settingDesc" module="corpus" mode="change">
                  <content>
                     <elementRef key="setting" minOccurs="1" maxOccurs="unbounded"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                  </content>
               </elementSpec>
               <moduleRef key="header" include="abstract catDesc catRef category change correspAction correspContext correspDesc creation encodingDesc extent fileDesc handNote idno langUsage language listChange listPrefixDef notesStmt prefixDef profileDesc projectDesc publicationStmt rendition revisionDesc sourceDesc tagsDecl taxonomy teiHeader textClass titleStmt"/><elementSpec ident="change" mode="change" module="header">
                  <constraintSpec ident="changeMustPointToTeam" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:change">
                              <sch:assert test="every $ptr in tokenize(@who,'\s+') satisfies matches($ptr,'^team:')">
                                 ERROR: Every pointer in change/@who must start with 'team:'.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="changeMustHaveContent" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:change">
                              <sch:assert test="not(normalize-space(string-join(descendant::text(),'')) = '')">
                                 ERROR: change elements must contain meaningful content.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="who" mode="change" usage="req"/>
                     <attDef ident="when" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="correspAction" module="header" mode="change">
                  <classes mode="change">
                     <memberOf key="att.datable" mode="add"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.ascribed" mode="add"/>
                  </classes>
                  <content>
                     <!--Allow for empty content-->
                     <alternate>
                        <classRef key="model.correspActionPart" minOccurs="0" maxOccurs="unbounded"/>
                        <classRef key="model.pLike" minOccurs="0" maxOccurs="unbounded"/>
                     </alternate>
                  </content>
               </elementSpec><elementSpec ident="creation" module="header" mode="change">
                  <content>
                     <sequence>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <constraintSpec ident="onlyUseCreationForAccountsNarratives" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:creation">
                              <sch:assert test="ancestor::tei:profileDesc/tei:limItem[@type=                                  ('accountNarrative','conversation','misc', 'speech')]">ERROR: The creation element should only be used for account/narratives, conversations, and speeches, since the date/place of the transcription may differ from the setting.</sch:assert>
                              <sch:assert test="count(tei:*) gt 0">ERROR: The creation element requires at least one of placeName, date, or note.</sch:assert>
                           </sch:rule>
                           
                        </sch:pattern>
                        
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="langUsage" module="header" mode="change">
                  <content>
                     <elementRef key="language" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="profileDesc" module="header" mode="change">
                  <content>
                     <alternate>
                        <sequence>
                           <alternate>
                              <sequence>
                                 <elementRef key="locusGrp"/>
                                 <elementRef key="locus" minOccurs="0" maxOccurs="1"/>
                              </sequence>
                              <elementRef key="locus" minOccurs="1" maxOccurs="2"/>
                           </alternate>
                           <elementRef key="abstact" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="langUsage" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="limItem"/>
                        </sequence>
                        <elementRef key="catRef"/>
                     </alternate>
                  </content>
               </elementSpec><elementSpec ident="revisionDesc" mode="change" module="header">
                  <content>
                     <elementRef key="change" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
                  <constraintSpec ident="revisionDescStatusMustMatch" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc">
                              <sch:let name="firstChangeWithDocStatus" value="tei:change[@docStatus][1]"/>
                              <sch:let name="firstChangeWithMetaStatus" value="tei:change[@metaStatus][1]"/>
                              <sch:let name="docStatus" value="@docStatus"/>
                              <sch:let name="metaStatus" value="@metaStatus"/>
                              <sch:assert test="exists($firstChangeWithDocStatus) = exists($metaStatus)">
                                 ERROR: If @docStatus appears on a change element or on a revisionDesc, then both the revisionDesc element and at least one change element must feature @docStatus.  
                              </sch:assert>
                              <sch:assert test="exists($firstChangeWithMetaStatus) = exists($metaStatus)">
                                 ERROR: If @metaStatus appears on a change element or on a revisionDesc, then both the revisionDesc element and at least one change element must feature @metaStatus.  
                              </sch:assert>
                              <sch:assert test="exists($docStatus) or exists($metaStatus)">
                                 ERROR: At least one of @docStatus or @metaStatus must be present.
                              </sch:assert>
                              <sch:assert test="$docStatus = $firstChangeWithDocStatus/@docStatus">
                                 ERROR: The docStatus of the revisionDesc must match the latest change/@docStatu
                              </sch:assert>
                              <sch:assert test="$metaStatus = $firstChangeWithMetaStatus/@metaStatus">
                                 ERROR: The metaStatus of the revisionDesc must match the latest change/@metaStatus
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="revisionDescEarliest" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[count(tei:change[@when]) gt 1]">
                              <sch:let name="firstChange" value="tei:change[1]"/>
                              <sch:let name="secondChange" value="tei:change[2]"/>
                              <sch:let name="firstDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:let name="secondDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:assert test="($firstDate gt $secondDate) or ($firstDate = $secondDate)">
                                 ERROR: Change elements should be ordered reverse chronologically (latest first).
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="textClass" module="header" mode="change">
                  <!--Add constraints to force either a correspDesc or a settingDesc-->
               </elementSpec>
               <moduleRef key="figures" include="cell figDesc figure row table"/>
               <moduleRef key="gaiji" include="char charDecl g localProp mapping"/><elementSpec ident="g" module="gaiji" mode="change">
                  <attList>
                     <attDef ident="ref" mode="change" usage="req">
                        <datatype>
                           <dataRef key="limdata.glyph"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>In most cases, the <gi>noteMarker</gi> element is more appropriate,
                     except in cases where the marker is in another hand; in that case, use the g
                     element.</p>
                  </remarks>
               </elementSpec>
               <moduleSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim"/><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="compliment" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="compliments" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="compliment" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="duration" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                  </classes>
                  <content>
                     <macroRef key="macro.paraContent"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="enclosure" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="enclosures" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="enclosure" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="limItem" module="lim" mode="add">
                  <desc>contains a set of descriptional elements for a text that serves as the basis for a containing text.</desc>
                  <classes>
                     <memberOf key="att.typed"/>
                  </classes>
                  <content>
                     <sequence preserveOrder="false">
                        <alternate>
                           <elementRef key="correspDesc" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="settingDesc" minOccurs="0" maxOccurs="1"/>
                        </alternate>
                        <elementRef key="creation" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="noteGrp" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="author" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="limItem" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="bibl" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList type="closed" mode="add">
                           <valItem ident="poemSongEpitaph" mode="add">
                              <gloss>poem / song / epitaph</gloss>
                              <desc>poem / song / epitaph</desc>
                           </valItem>
                           <valItem ident="letter" mode="add">
                              <desc>letter</desc>
                              <gloss>letter</gloss>
                           </valItem>
                           <valItem ident="accountNarrative" mode="add">
                              <desc>account / narrative</desc>
                              <gloss>account / narrative</gloss>
                           </valItem>
                           <valItem ident="speech" mode="add">
                              <desc>speech</desc>
                              <gloss>speech</gloss>
                           </valItem>
                           <valItem ident="conversation" mode="add">
                              <desc>conversation</desc>
                              <gloss>conversation</gloss>
                           </valItem>
                           <valItem ident="insert" mode="add">
                              <desc>insert</desc>
                              <gloss>insert</gloss>
                           </valItem>
                           <valItem ident="misc" mode="add">
                              <desc>miscellaneous</desc>
                              <gloss>miscellaneous</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="NB" mode="add" module="lim">
                  <gloss>nota bene</gloss>
                  <desc>groups together content that is marked as a nota bene.</desc>
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.written"/>
                     <memberOf key="model.divPart"/>
                     <memberOf key="model.divBottomPart"/>
                  </classes>
                  <content>
                     <sequence>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.divTopPart"/>
                        </alternate>
                        <classRef key="model.common"/>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.common"/>
                        </alternate>
                        <sequence minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.divBottomPart"/>
                           <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                     </sequence>
                  </content>
                  <remarks>
                     <p>The <gi>NB</gi> element is modelled after the <gi>postscript</gi> element
                        as Forbes frequently uses NBs in multiple contexts (including as trailing 
                        content, or as the entirety of an element).</p>
                     <p>When a NB is used as the content of a footnote, 
                        wrap the <gi>NB</gi> in the <gi>note</gi>.</p>
                     <p>We assume that all <gi>NB</gi> elements are written by Forbes (i.e. the implied value of <att>resp</att> is prs:FORBR1).</p>
                  </remarks>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="noteMarker" mode="add" module="lim">
                  <classes>
                     <memberOf key="model.milestoneLike"/>
                  </classes>
                  <content>
                     <textNode/>
                  </content>
                  <constraintSpec ident="noteMarker.mustHaveTargetInNote" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note/tei:noteMarker | tei:note/tei:supplied/tei:noteMarker">
                              <sch:assert test="@target">ERROR: Note markers in a note should have a target
                                 pointing to the source note marker.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:noteMarker[not(parent::tei:note)] | tei:noteMarker[not(parent::tei:supplied/parent::tei:note)]">
                              <sch:assert test="@xml:id">ERROR: Note markers in the body of text should 
                              have an xml:id identifying it. (This should be automatic if you use
                              the keyboard shortcut Command + Shift + N)</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.allTargetsShouldStartWithHash" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:noteMarker[@target]">
                              <sch:let name="localTargs" value="tokenize(@target,'\s+')"/>
                              <sch:assert test="every $targ in $localTargs satisfies matches($targ,'^(doc:[^#]+)?#')">ERROR: Every target in noteMarker must start with a '#' or a "doc:" pointer with a hash reference.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.allTargsShouldExist" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:noteMarker[@target]">
                              <sch:let name="noteMarker" value="."/>
                              <sch:let name="localTargs" value="tokenize(@target,'\s+')[matches(.,'^#')]"/>
                              <sch:let name="noteMarkers" value="ancestor::tei:TEI/descendant::tei:noteMarker[@xml:id]"/>
                              <sch:let name="badPointers" value="for $targ in $localTargs return                                  let $note := $noteMarkers[@xml:id = substring-after($targ,'#')]                                  return if (exists($note) and $note[. &lt;&lt; $noteMarker]) then ()                                  else $targ"/>
                               <sch:assert test="empty($badPointers)">ERROR: Cannot find preceding noteMarker for target<sch:value-of select="if (count($badPointers) gt 1) then 's' else ()"/>: <sch:value-of select="string-join($badPointers,' ')"/>.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.mustHaveContentIfUnknown" scheme="schematron">
                     <constraint>
                        
                        <sch:rule context="tei:noteMarker[@ref='g:UNKNOWN']">
                           <sch:assert test="matches(string(.), '\S')">ERROR: You must provide a character in the noteMarker when using g:UNKNOWN</sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:noteMarker[@ref][not(@ref = 'g:UNKNOWN')]">
                           <sch:assert test="empty(text())">ERROR: No text content is allowed in noteMarker unless @ref='g:UNKNOWN'</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="noteMarker.mustHaveIdFollowingFormat" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:noteMarker[not(parent::tei:note[@anchored='true'] or parent::tei:supplied/parent::tei:note[@anchored='true'])]">
                           <sch:let name="prePage" value="preceding::tei:pb[1]"/>
                           <sch:let name="prePageVal" value="if ($prePage) then substring-after($prePage/@facs,'pg:') else tokenize(ancestor::tei:TEI/@xml:id,'\.')[2]"/>
                           <sch:let name="prePageInt" value="xs:integer($prePageVal)"/>
                           <sch:let name="preNotes" value="preceding::tei:noteMarker[@xml:id]"/>
                           <sch:let name="noteNum" value="(if (exists($prePage)) then count($preNotes[. &gt;&gt; $prePage]) else count($preNotes)) + 1"/>
                           <sch:let name="noteMarkerId" value="'p' || $prePageVal || '_n' || $noteNum"/>
                           <sch:assert test="@xml:id and (@xml:id = $noteMarkerId)">ERROR: @xml:id of noteMarker should be <sch:value-of select="$noteMarkerId"/>.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <!--Identical to the ref on glyph-->
                     <attDef ident="ref" usage="req">
                        <desc versionDate="2005-01-14" xml:lang="en">points to a description of the character or glyph intended.</desc>
                        <desc versionDate="2007-05-02" xml:lang="zh-TW">連結到該文字或字體的描述。</desc>
                        <desc versionDate="2008-04-05" xml:lang="ja">当該文字やグリフの解説を参照する．</desc>
                        <desc versionDate="2007-06-12" xml:lang="fr">pointe vers la description du caractère ou du glyphe
                            visé</desc>
                        <desc versionDate="2007-05-04" xml:lang="es">indica la descripción del carácter o pictograma dado.</desc>
                        <desc versionDate="2007-01-21" xml:lang="it">punta a una descrizione del carattere o glifo.</desc>
                        <datatype>
                           <dataRef key="limdata.glyph"/>
                        </datatype>
                     </attDef>
                     <attDef ident="annotation" usage="opt">
                        <desc>describes any penciled annotation surrounding this note marker</desc>
                        <valList type="closed">
                           <valItem ident="circle">
                              <gloss>circle</gloss>
                              <desc>circled in pencil</desc>
                           </valItem>
                           <valItem ident="strike">
                              <gloss>strike</gloss>
                              <desc>Struck out in pencil</desc>
                           </valItem>
                        </valList>
                        <remarks>
                           <p>This <att>annotation</att> attribute is something of a shortcut 
                           for the <gi>add</gi> element to better describe some kind of phenomena around
                           a note marker added by a later annotator.</p>
                        </remarks>
                     </attDef>
                     <attList org="choice">
                        <attDef ident="xml:id" usage="rec">
                           <gloss versionDate="2007-07-02" xml:lang="en">identifier</gloss>
                           <gloss versionDate="2007-12-20" xml:lang="ko">확인소</gloss>
                           <gloss versionDate="2008-04-06" xml:lang="es">identificador</gloss>
                           <gloss versionDate="2008-03-30" xml:lang="fr">identifiant</gloss>
                           <gloss versionDate="2007-11-06" xml:lang="it">identificatore</gloss>
                           <gloss xml:lang="ja" versionDate="2019-06-08">識別子</gloss>
                           <desc versionDate="2005-10-10" xml:lang="en">provides a unique identifier for the element bearing the attribute.</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">속성을 포함하는 요소에 대한 고유한 확인소를 제공한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">提供一個獨特識別符碼，識別帶有該屬性的元素。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">当該要素にユニークな識別子を示す．</desc>
                           <desc versionDate="2009-05-25" xml:lang="fr">fournit un identifiant unique pour l'élément qui
                              porte l'attribut</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">proporciona un identificador único para el elemento
                              al cual se asocia el atributo.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">assegna un identificatore unico all'elemento a cui è
                              associato l'attributo</desc>
                           <datatype><dataRef name="ID"/></datatype>
                           <remarks versionDate="2005-10-10" xml:lang="en">
                              <p>The <att>xml:id</att> attribute may be used to specify a canonical reference for an
                                 element; see section <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="fr" versionDate="2007-06-12">
                              <p>L'attribut <att>xml:id</att> peut être employé pour indiquer une référence canonique pour
                                 un élément ; voir la section<ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="es" versionDate="2008-04-06">
                              <p>El atributo <att>xml:id</att> se puede utilizar para especificar una referencia canónica
                                 para un elemento; ver la sección <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="ja" versionDate="2008-04-05">
                              <p> 当該属性<att>xml:id</att>は，属性の指示対象を示している．詳細 は<ptr target="#CORS"/>を参照のこと． </p>
                           </remarks>
                        </attDef>
                        <attDef ident="target" usage="req">
                           <desc versionDate="2010-05-02" xml:lang="en">specifies the destination of the reference by supplying one or more URI References</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">하나 혹은 다수의 URI 참조를 제시하여 참조의 목적지를 명시한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">用一個或多個統一資源識別符參照 (URI References) 來說明參照所指位置。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">ひとつ以上のURIで，参照先を特定する．</desc>
                           <desc versionDate="2009-01-06" xml:lang="fr">précise la cible de la référence en donnant une ou
                              plusieurs références URI</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">especifica la destinación de una referencia
                              proporcionando una o más referencias URI.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">specifica la destinazione di un riferimento, fornendo
                              uno o più riferimenti URI</desc>
                           <datatype maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
                           <remarks versionDate="2007-01-21" xml:lang="en"><p>One or more syntactically valid URI references, separated by whitespace. Because
                              whitespace is used to separate URIs, no whitespace is permitted inside a single URI. If a
                              whitespace character is required in a URI, it should be escaped with the normal mechanism,
                              e.g. <code>TEI%20Consortium</code>.</p></remarks>
                           <remarks versionDate="2007-01-21" xml:lang="fr"><p>Une ou plusieurs références URI syntaxiquement valables, séparée par
                              un espace. Puisqu'un espace  est employé pour séparer des URIs, aucun espace
                              n’est autorisé à l'intérieur d'un URI. Si un espace est requis dans un URI, il
                              faut le représenter avec une séquence d'échappement, comme par exemple 
                              <code>TEI%20Consortium</code>.</p></remarks>
                        </attDef>
                     </attList>
                  </attList>
                  
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="request" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="requests" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="request" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="scaffold" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                     <memberOf key="lim.att.locatable"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:scaffold[@value = 'true']">
                              <sch:assert test="tei:placeName or @where">
                      ERROR: If this is a scaffold speech, then it must have a place associated
                      for the location of the execution (either using a @where or a child placeName element).
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="value">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                     <attDef ident="where" mode="change">
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <valList mode="add" type="semi">
                           <valItem ident="plc:TOWE1" mode="add">
                              <desc>Tower of London</desc>
                              <gloss>Tower of London</gloss>
                           </valItem>
                           <valItem ident="plc:KENN1" mode="add">
                              <desc>Kennington Common</desc>
                              <gloss>Kennington Common</gloss>
                           </valItem>
                           <valItem ident="plc:CARL2" mode="add">
                              <desc>Carlisle</desc>
                              <gloss>Carlisle</gloss>
                           </valItem>
                           <valItem ident="plc:BRAM1" mode="add">
                              <desc>Brampton</desc>
                              <gloss>Brampton</gloss>
                           </valItem>
                           <valItem ident="plc:PENR1" mode="add">
                              <desc>Penrith</desc>
                              <gloss>Penrith</gloss>
                           </valItem>
                           <valItem ident="plc:YORK1" mode="add">
                              <desc>York</desc>
                              <gloss>York</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="rule" module="lim" mode="add">
                  <gloss>rule</gloss>
                  <desc>marks a ruled line</desc>
                  <classes>
                     <memberOf key="model.milestoneLike"/>
                     <memberOf key="att.milestoneUnit"/>
                  </classes>
                  <content>
                     <elementRef key="desc" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="rule.onlyPlaceWithExtentLessThan100" scheme="schematron">
                     <desc>The <att>place</att> attribute only makes sense when extent is less than 100%</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:rule[@place]">
                              <sch:assert test="exists(@extent) and xs:integer(replace(@extent,'%','')) lt 100">ERROR: @place only makes sense if an @extent exists and is less than 100%.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="rule.extentShouldBeIntegerLeq100" scheme="schematron">
                     <desc>The <att>extent</att> of a <gi>rule</gi> should be between 1 and 100%</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:rule[@extent]">
                              <sch:let name="int" value="xs:integer(replace(@extent,'%',''))"/>
                              <sch:assert test="$int = (1 to 100)">ERROR: @extent should be a percentage value between 1 and 100.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="rule.usedToUseMilestone" scheme="schematron">
                     <desc>We used to use the milestone element, but that construct is now deprecated.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:milestone">
                              <sch:assert test="not(ancestor::tei:text)">ERROR: milestone elements for ruled lines are deprecated. Use &lt;rule&gt; instead.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" usage="req" mode="change">
                        <valList mode="replace">
                           <valItem ident="section">
                              <gloss>section</gloss>
                              <desc>a rule separating sections of some sort on
                                 the page, but not between items.</desc>
                           </valItem>
                           <valItem ident="item">
                              <gloss>item</gloss>
                              <desc>a rule that separates items.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="extent" usage="opt">
                        <desc>the extent of the rule in percentage. By default, 100%.</desc>
                        <datatype>
                           <dataRef name="token" restriction="\d+%"/>
                        </datatype>
                        <defaultVal>100%</defaultVal>
                        <valList type="semi">
                           <valItem ident="25%">
                              <gloss>25%</gloss>
                              <desc>A quarter of the page</desc>
                           </valItem>
                           <valItem ident="50%">
                              <gloss>50%</gloss>
                              <desc>Half of the page</desc>
                           </valItem>
                           <valItem ident="75%">
                              <gloss>75%</gloss>
                              <desc>Three-quarters of the page</desc>
                           </valItem>
                           <valItem ident="100%">
                              <gloss>100%</gloss>
                              <desc>The entire width of the page.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="place" usage="opt">
                        <desc>specifies where this item is placed.</desc>
                        <valList type="closed">
                           <valItem ident="left">
                              <gloss>left</gloss>
                              <desc>left</desc>
                           </valItem>
                           <valItem ident="right">
                              <gloss>right</gloss>
                              <desc>right</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="rendition" usage="opt">
                        <desc>Rendition</desc>
                        <valList type="closed">
                           <valItem ident="rnd:dashed">
                              <gloss>a dashed line</gloss>
                              <desc>a dashed line</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>This element is semantically equivalent to the standard TEI <gi>milestone</gi> with <att>rendition</att> values. However, it may contain an optional <gi>desc</gi> child if further description of line is necessary.</p>
                     <p>The <att>place</att> attribute (which is borrowed from att.placement) has no bearing on <gi>rule</gi> elements that do not specify an <att>extent</att> less than 100% (which is the default).</p>
                  </remarks>
               </elementSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.boolean" mode="add" module="lim" type="atts">
                  <attList>
                     <attDef ident="value" usage="rec">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.global.fragmentable" mode="add" module="lim" type="atts">
                  <desc versionDate="2021-08-22" xml:lang="en">provides attributes for representing
                     fragmentation of a structural element, typically as 
                     a consequence of some overlapping hierarchy.</desc>
                  <attList>
                     <attDef ident="part" usage="opt">
                        <desc versionDate="2013-06-21" xml:lang="en">specifies whether or not its parent element is fragmented
                           in some way, typically by some other overlapping structure: for
                           example a speech which is divided between two or more verse
                           stanzas, a paragraph which is split across a page division, a
                           verse line which is divided between two speakers.</desc>
                        <datatype>
                           <dataRef key="teidata.enumerated"/>
                        </datatype>
                        <valList type="closed">
                           <valItem ident="Y">
                              <gloss versionDate="2013-01-07" xml:lang="en">yes</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">はい</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is fragmented in some (unspecified) respect</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素はいくつかの（不特定の）点で断片化されている。</desc>
                           </valItem>
                           <valItem ident="N">
                              <gloss versionDate="2013-01-07" xml:lang="en">no</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">いいえ</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is not fragmented, or no claim is made as to its completeness</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素が断片化されていないか，または完全性についての主張はない。</desc>
                           </valItem>
                           <valItem ident="I">
                              <gloss versionDate="2013-01-07" xml:lang="en">initial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最初の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the initial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最初の部分を示す。</desc>
                           </valItem>
                           <valItem ident="M">
                              <gloss versionDate="2013-01-07" xml:lang="en">medial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">中間の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is a medial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の中間の部分を示す。</desc>
                           </valItem>
                           <valItem ident="F">
                              <gloss versionDate="2013-01-07" xml:lang="en">final</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最後の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the final part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最後の部分を示す。</desc>
                           </valItem>
                        </valList>
                        <remarks versionDate="2013-01-07" xml:lang="en">
                           <p>The values <val>I</val>, <val>M</val>, or <val>F</val>
                              should be used only where it is clear how the element may
                              be reconstituted.</p>
                        </remarks>
                        <remarks xml:lang="ja" versionDate="2019-06-08">
                           <p>
                              <val>I</val>，<val>M</val>，または<val>F</val>という値は，要素の再構成方法が明らかな場合にのみ使用する。</p>
                        </remarks>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The same as TEI's att.fragmentable, but turned into its own class
                     to make it global.</p>
                  </remarks>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.locatable" module="lim" type="atts" mode="add">
                  <classes>
                     <memberOf key="lim.att.locatable.directed"/>
                  </classes>
                  <attList>
                     <attDef ident="where" usage="opt">
                        <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.att.locatable.directed" module="lim" type="atts" mode="add">
                  <attList>
                     <attDef ident="toWhere" usage="opt">
                        <desc>indicates the location of something being sent.</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><macroSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="lim.personMacro" module="lim" mode="add">
                  <content>
                    <sequence>
                       <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
                       <!--NOTE: preserveORder doesn't actually work, but there
                may be a new element coming: see
                https://github.com/TEIC/TEI/issues/2154 -->
                       <sequence preserveOrder="false">
                          <elementRef key="sex" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="birth" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="death" minOccurs="0" maxOccurs="1"/>
                          <elementRef key="faith" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="affiliation" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="occupation" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="nationality" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="residence" minOccurs="0" maxOccurs="unbounded"/>
                          <elementRef key="figure" minOccurs="0" maxOccurs="unbounded"/>
                       </sequence>
                       <!--Always make langKnowledge and note come last-->
                       <elementRef key="langKnowledge" minOccurs="0" maxOccurs="1"/>
                       <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                    </sequence> 
                  </content>
               </macroSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.ana" mode="add">
                  <desc>Datatype for all analytic pointers</desc>
                  <content>
                     <valList>
                        <valItem ident="lim:women">
                           <desc>women</desc>
                           <gloss>women</gloss>
                        </valItem>
                        <valItem ident="lim:gaelic">
                           <desc>gaelic</desc>
                           <gloss>gaelic</gloss>
                        </valItem>
                        <valItem ident="lim:media">
                           <desc>media</desc>
                           <gloss>media</gloss>
                        </valItem>
                        <valItem ident="lim:class">
                           <desc>class</desc>
                           <gloss>class</gloss>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.facs" mode="add">
                  <desc>Datatype for all lim facsimile pointers.</desc>
                  <content>
                     <dataRef name="token" restriction="(lib|pg):\d+(.\d+)?"/>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.glyph" mode="add">
                  <desc>Datatype for all glyph pointers.</desc>
                  <content>
                     <valList type="closed"><valItem ident="g:star"><gloss>star</gloss><desc>STAR / ASTERISK (*)</desc></valItem><valItem ident="g:cross"><gloss>cross</gloss><desc>CROSS OR DAGGER (✝)</desc></valItem><valItem ident="g:x"><gloss>x</gloss><desc>X (X)</desc></valItem><valItem ident="g:circledX"><gloss>circledX</gloss><desc>X WITH CIRCLE (ⓧ)</desc></valItem><valItem ident="g:phi"><gloss>phi</gloss><desc>PHI (φ)</desc></valItem><valItem ident="g:theta"><gloss>theta</gloss><desc>THETA (θ)</desc></valItem><valItem ident="g:umbrella"><gloss>umbrella</gloss><desc>UMBRELLA (☂)</desc></valItem><valItem ident="g:tau"><gloss>tau</gloss><desc>TAU (Τ)</desc></valItem><valItem ident="g:pi"><gloss>pi</gloss><desc>PI (Π)</desc></valItem><valItem ident="g:UNKNOWN"><gloss>UNKNOWN</gloss><desc>UNKNOWN</desc></valItem></valList>
                  </content>
               </dataSpec><dataSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" module="lim" ident="limdata.placement" mode="add">
                  <desc>Possible values for placement.</desc>
                  <content>
                     <valList type="closed">
                        <valItem ident="bottom">
                           <gloss>bottom</gloss>
                           <desc>at the foot of the page</desc>
                        </valItem>
                        <valItem ident="left" mode="add">
                           <gloss>left</gloss>
                           <desc>in the left margin</desc>
                        </valItem>
                        <valItem ident="center" mode="add">
                           <gloss>center</gloss>
                           <desc>in the center</desc>
                        </valItem>
                        <valItem ident="right" mode="add">
                           <gloss>right</gloss>
                           <desc>in the right margin</desc>
                        </valItem>
                        <valItem ident="above" mode="add">
                           <gloss>above</gloss>
                           <desc>above the line</desc>
                        </valItem>
                        <valItem ident="below" mode="add">
                           <gloss>below</gloss>
                           <desc>below the line</desc>
                        </valItem>
                        <valItem ident="inline" mode="add">
                           <gloss>inline</gloss>
                           <desc>an inline note</desc>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="fwPbConstraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for formeworks and page beginnings.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:fw | tei:pb">
                           <sch:assert test="parent::tei:ab | parent::tei:back | parent::tei:body | parent::tei:div | parent::tei:front | parent::tei:list | parent::tei:p | parent::tei:text | parent::tei:q | parent::tei:note | parent::tei:lg | parent::tei:head | parent::tei:NB | parent::tei:closer | parent::tei:dateline | parent::tei:signed">
                              ERROR: <sch:name/> should not appear within <sch:value-of select="local-name(parent::*)"/>.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:fw">
                           <sch:assert test="not(tei:lb)">ERROR: <sch:name/> should not contain line beginnings 
                              (since they are usually a single line)</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="global.rootIdMustMatchDocument">
                  <desc>The rootid must be the same as the document's name.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:*">
                           <sch:let name="rootEl" value="local-name()"/>
                           <sch:let name="correctDir" value="                     if (self::tei:person and @role='contributor') then 'contributors'                     else if (self::tei:person) then 'people'                     else if (self::tei:place) then 'places'                     else if (self::tei:org) then 'orgs'                     else $dirName"/>
                           <sch:assert test="$basename = $id">
                    ERROR: Document's @xml:id (<sch:value-of select="$id"/>) must match the document's base filename
                    (<sch:value-of select="$basename"/>)
                  </sch:assert>
                           <sch:assert test="$dirName = $correctDir">
                    ERROR: All <sch:value-of select="if (self::person/@role) then @role else local-name()"/> files should added to the <sch:value-of select="$correctDir"/> folder. This file (<sch:value-of select="$id"/>) is in the <sch:value-of select="$dirName"/> folder.
                  </sch:assert>
                           <!--<sch:rule context="/tei:person[not(@role='contributor')]">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All people should be added to the /people/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:person[@role='contributor']">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All contributors should be added to the /contributors/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:org">
                    <sch:assert test="$dirName = 'orgs'">
                      ERROR: All orgs should be added to the /orgs/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:place">
                    <sch:assert test="$dirName = 'places'">
                      ERROR: All places should be added to the /places/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="global.variables">
                  <desc>Global variables for use across the schematron.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:let name="id" value="/tei:*/@xml:id"/>
                        <sch:let name="uri" value="document-uri(/)"/>
                        <sch:let name="tokens" value="tokenize($uri,'[/\\]')"/>
                        <sch:let name="basename" value="replace($tokens[last()],'\.xm[l_]$','')"/>
                        <sch:let name="dirName" value="$tokens[last() - 1]"/>
                        <sch:let name="placeIdPattern" value="'[A-Z]{4}\d+'"/>
                        <sch:let name="orgIdPattern" value="'[A-Z]{4}\d+(_[^_]+)*'"/>
                        <sch:let name="persIdPattern" value="'[A-Z]{5}\d+'"/>
                        <sch:let name="cutoff" value="xs:date('1752-09-02')"/>
                        <sch:let name="root" value="root(.)"/>
                        <sch:let name="docStatus" value="//tei:revisionDesc/@docStatus"/>
                        <sch:let name="isBornDigital" value="exists($root//tei:catRef[matches(@target,'bornDigital')])"/>
                        <sch:let name="isItem" value="exists($root//tei:limItem)"/>
                        <!-- <sch:let name="pd" value="replace($uri,'^(.+[/\\]lim-tei[\\/]).+$', '$1')"/>
                <sch:let name="dataDir" value="replace($pd,'(.+(.))$','$1data$2')"/>
                <sch:let name="glyphs"
                  value="document($dataDir || 'glyphs.xml')//tei:glyph[@xml:id]"/> -->
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" scheme="schematron" ident="inlineElementsNoSpaces">
                  <desc>Inline elements should not begin or end with spaces.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:title | tei:num | tei:ref | tei:rs | tei:placeName[not(parent::tei:place)] | tei:persName[not(parent::tei:person)] | tei:objectName[not(parent::tei:object)] | tei:date[ancestor::tei:text] | tei:time[ancestor::tei:text]">
                           <sch:let name="text" value="string(.)"/>
                           <sch:assert test="not(matches($text, '^\s+|\s+$'))">
                    ERROR: <sch:name/> should not begin or end with spaces.
                  </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="metadataContraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for profileDesc / premediation.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:limItem">
                           <sch:let name="genre" value="@type"/>
                           <sch:assert test="if (matches($genre, 'letter','i')) then tei:correspDesc else true()">
                              ERROR: All letters must have a correspDesc.
                           </sch:assert>
                           <sch:assert test="if (matches($genre,'Speech|Account|Conversation','i')) then tei:settingDesc else true()">
                              ERROR: All <sch:value-of select="$genre"/> must have a settingDesc.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec xmlns:xsl="http://www.w3.org/1999/XSL/Transform" ident="textConstraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for text and punctuation</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:*[text()][matches(string-join(text(),''),'\S')][ancestor::tei:text][$docStatus=('draft','inProgress','proofed', 'readyForProof')]">
                           <sch:let name="string" value="string-join(text(),'')"/>
                           <sch:assert test="not(matches($string,'(--+)|(––+)'))">
                              ERROR: Do not use multiple hyphens or en-dashes to represent an em-dash (—).
                           </sch:assert>
                          <!-- <sch:assert test="not(matches(., $sq)) and not(ancestor::tei:code | ancestor::*:egXML)">
                              ERROR: Straight quotation marks should be replaced by curly ones
                           </sch:assert>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <moduleRef key="linking" include="ab linkGrp ptr seg standOff"/><elementSpec ident="anchor" module="linking" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.rendition" mode="delete"/>
                     <memberOf key="att.global.change" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="att.global.source" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="delete"/>
                     <memberOf key="att.type" mode="delete"/>
                     <memberOf key="lim.att.global.fragmentable" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="xml:id" usage="req" mode="change"/>
                     <attDef ident="xml:space" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="seg" module="linking" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.choicePart"/>
                  </classes>
                  <constraintSpec ident="seg.onlyAllowedInEllipsis" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:choice[tei:seg]">
                              <sch:assert test="parent::tei:supplied/parent::tei:ellipsis">
                                 ERROR: choice/seg is allowed ONLY within a supplied and ellipsis.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <remarks>
                     <p><gi>seg</gi> is allowed only within a <gi>choice</gi> (and only when the choice is within a supplied and metamark).</p>
                  </remarks>
               </elementSpec><elementSpec ident="standOff" module="linking" mode="change">
                  <constraintSpec ident="standoff.elementsMustUseCopyOfORHaveAPersName" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:standOff/tei:*[not(self::tei:listQuote)]/tei:*[not(self::tei:head)]">
                              <sch:assert test="@copyOf or tei:*">
                      ERROR: <sch:name/> elements need either a @copyOf that points to an existing <sch:name/> OR content.
                    </sch:assert>
                              <sch:assert test="not(@copyOf and tei:*)">
                      ERROR: <sch:name/> elements should have either a <sch:name/>Name element OR a @copyOf, but not both.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="msdescription" include="additional adminInfo collection custodialHist history locus locusGrp msContents msDesc msIdentifier msItem msName msPart objectDesc origin physDesc repository summary supportDesc surrogates"/><elementSpec ident="locus" module="msdescription" mode="replace">
                  <gloss xml:lang="en" versionDate="2007-06-12">locus</gloss>
                  <desc versionDate="2019-01-17" xml:lang="en" xml:id="locus.desc">defines a location within a manuscript, manuscript part, or other object typically 
                     as a (possibly discontinuous) sequence of folio references.</desc>
                  <constraintSpec ident="locus.rangesMustMakeSense" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locus[@from and @to]">
                              <sch:let name="from" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:let name="to" value="xs:integer(replace(@to,'[^\d]+',''))"/>
                              <sch:assert test="$from lt ($to + 1)">
                                 ERROR: @to value should not be less than @from. If you need to specify
                                 a set of discontinuous pages (i.e. spanning across a pageGroup), use a locusGrp.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="PatonLocus.mustBeWithinBounds" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locus[@type='Paton'][@n and @from and @to]">
                              <sch:let name="n" value="@n"/>
                              <sch:let name="max" value="if (@n = '1') then 382                                   else if (@n = '2') then 380 else 416"/>
                              <sch:let name="from" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:let name="to" value="xs:integer(replace(@from,'[^\d]+',''))"/>
                              <sch:assert test="$from lt ($max + 1)">
                                 ERROR: @from value out of range: Paton volume <sch:value-of select="$n"/> contains <sch:value-of select="$max"/> pages.
                              </sch:assert>
                              <sch:assert test="$to lt ($max + 1)">
                                 ERROR: @to value out of range: Paton volume <sch:value-of select="$n"/> contains <sch:value-of select="$max"/> pages.
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList org="group">
                     <attDef ident="from" usage="req">
                        <gloss xml:lang="en" versionDate="2007-06-12">from</gloss>
                        <desc versionDate="2013-12-21" xml:lang="en">specifies the
                           starting point of the location in a normalized form, typically a
                           page number.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                     </attDef>
                     <attDef ident="to" usage="req">
                        <gloss xml:lang="en" versionDate="2007-06-12">to</gloss>
                        <desc versionDate="2013-12-21" xml:lang="en">specifies the
                           end-point of the location in a normalized form, typically as a
                           page number.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                     </attDef>
                     <attList org="choice">
                        <attList org="group">
                           <attDef ident="type" usage="req" mode="replace">
                              <valList type="closed">
                                 <valItem ident="Forbes" mode="add">
                                    <desc>Forbes</desc>
                                    <gloss>A Forbes page range</gloss>
                                 </valItem>
                              </valList>
                           </attDef>
                        </attList>
                        <attList org="group">
                           <attDef ident="type" usage="req" mode="replace">
                              <valList type="closed">
                                 <valItem ident="Paton" mode="add">
                                    <desc>Paton</desc>
                                    <gloss>A Paton page range</gloss>
                                 </valItem>
                              </valList>
                           </attDef>
                           <attDef ident="n" usage="req">
                              <gloss versionDate="2007-07-02" xml:lang="en">number</gloss>
                              <desc versionDate="2005-10-10" xml:lang="en">gives a number (or other label) for an element, which is not necessarily unique within
                                 the document.</desc>
                              <datatype maxOccurs="1">
                                 <dataRef name="positiveInteger">
                                    <dataFacet name="maxInclusive" value="3"/>
                                 </dataRef>
                              </datatype>
                              <remarks versionDate="2013-12-06" xml:lang="en">
                                 <p>The value of this attribute is always understood to be a single token, even if it contains space or other punctuation characters, and need not be composed of numbers only. It is typically used to specify the numbering of chapters, sections,
                                    list items, etc.; it may also be used in the specification of a standard reference system
                                    for the text.</p>
                              </remarks>
                           </attDef>
                        </attList>
                     </attList>
                  </attList>
               </elementSpec><elementSpec ident="locusGrp" module="msdescription" mode="change">
                  <constraintSpec ident="locusGrpVsLocus" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:locusGrp/tei:locus">
                              <sch:assert test="self::tei:locus[@type='Forbes']">
                                 ERROR: Every locus in a locusGrp must be of type "Forbes"
                              </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               <moduleRef key="namesdates" include="addName affiliation birth death faith floruit forename genName geo langKnowledge langKnown listObject listOrg listPerson listPlace location nameLink nationality object objectName occupation org orgName persName person persona place placeName residence roleName settlement sex surname"/><elementSpec ident="affiliation" module="namesdates" mode="change">
                  <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdAndProperlyNested">
                     <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                     <constraint>
                        <sch:rule context="tei:affiliation[@type=('clan','army')]">
                           <sch:assert test="matches(@ref,'org:')">ERROR: All <sch:value-of select="@type"/> affiliations must have a @ref that points to the org for that <sch:value-of select="@type"/>.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList type="closed" mode="replace">
                           <valItem ident="clan" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                           <valItem ident="army" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="birth" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="death" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="faith" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="rel:ChurchOfScotland" mode="add">
                              <desc>Church of Scotland</desc>
                              <gloss>Church of Scotland</gloss>
                           </valItem>
                           <valItem ident="rel:Episcopalian" mode="add">
                              <desc>Episcopalian</desc>
                              <gloss>Episcopalian</gloss>
                           </valItem>
                           <valItem ident="rel:Anglican" mode="add">
                              <desc>Anglican</desc>
                              <gloss>Anglican</gloss>
                           </valItem>
                           <valItem ident="rel:RomanCatholic" mode="add">
                              <desc>Roman Catholic</desc>
                              <gloss>Roman Catholic</gloss>
                           </valItem>
                           <valItem ident="rel:BritishOrthodox" mode="add">
                              <desc>British Orthodox</desc>
                              <gloss>British Orthodox</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="langKnowledge" module="namesdates" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.persStateLike"/>
                  </classes>
               </elementSpec><elementSpec ident="langKnown" module="namesdates" mode="change">
                  <classes mode="change">
              <!--Add @cert and @resp explicitly-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <attList>
              <!--We do not specify level of fluency-->
                     <attDef ident="level" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="listObject" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="object" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPerson" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="person" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPlace" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="place" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="nationality" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
              <!--Remove @role, which is provided by att.naming,
                but att.naming is a superset of att.canonical,
                which we want for ref.-->
                     <attDef ident="role" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="ntl:English" mode="add">
                              <desc>English</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="ntl:French" mode="add">
                              <desc>French</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="ntl:Spanish" mode="add">
                              <desc>Spanish</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="ntl:Irish" mode="add">
                              <desc>Irish</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="ntl:Scottish" mode="add">
                              <desc>Scottish</desc>
                              <gloss>Scottish</gloss>
                           </valItem>
                           <valItem ident="ntl:Prussian" mode="add">
                              <desc>Prussian</desc>
                              <gloss>Prussian</gloss>
                           </valItem>
                           <valItem ident="ntl:Austrian" mode="add">
                              <desc>Austrian</desc>
                              <gloss>Austrian</gloss>
                           </valItem>
                           <valItem ident="ntl:Hanoverian" mode="add">
                              <desc>Hanoverian</desc>
                              <gloss>Hanoverian</gloss>
                           </valItem>
                           <valItem ident="ntl:Italian" mode="add">
                              <desc>Italian</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                           <valItem ident="ntl:Dutch" mode="add">
                              <desc>Dutch</desc>
                              <gloss>Dutch</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="object" module="namesdates" mode="change">
                  <classes>
                     <memberOf key="att.docStatus" mode="delete"/>
                  </classes>
                  <content>
                     <elementRef key="objectName" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <remarks mode="add">
                     <p>Our use of object is not TEI conformant, but the break is fairly
                trivial: where objectName is simply used
              instead of objectIdentifier/objectName.</p>
                  </remarks>
               </elementSpec><elementSpec ident="org" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
              <!--Orgs must have an orgName-->
                     <elementRef key="orgName" minOccurs="1" maxOccurs="unbounded"/>
                     <!--Also needs a note-->
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <!--And may include a ptrGrp-->
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                     <!--And may have a list of suborganizations below it-->
                     <elementRef key="listOrg" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <attList>
                     <attDef ident="xml:id" mode="change" usage="req">
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlId">
                           <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                           <constraint>
                              <sch:rule context="/tei:org">
                                 <sch:assert test="matches(@xml:id, concat('^', $orgIdPattern, '$'))">ERROR: All main orgs must have an id that is a sequence of four letter and a digit.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdProperlyNested">
                           <desc>org ids must be inherited.</desc>
                           <constraint>
                              <sch:rule context="tei:org/tei:listOrg/tei:org">
                                 <sch:let name="parentId" value="ancestor::tei:org[1]/@xml:id"/>
                                 <sch:assert test="starts-with(@xml:id, $parentId)">ERROR: All sub organization ids must start with the id of its parent organization.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="orgName" module="namesdates" mode="change">
                  <constraintSpec ident="orgName.mustHaveRefWithOrg" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:orgName[not(parent::tei:org)][@ref]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^org:', $orgIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "org:" followed by 4 uppercase letters and a number (e.g. org:CLAN1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="persName" module="namesdates" mode="change">
                  <constraintSpec ident="persName.mustHaveRefWithPrs" mode="add" scheme="schematron">
                     <desc>All inline persNames must have a ref that points to the personography db.</desc>
                     <constraint>
                 <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName[not(parent::tei:person)][@ref]">
                           <sch:assert test="matches(@ref,concat('^prs:', $persIdPattern, '$'))">ERROR: All persName pointers must have an @ref that begins with "prs:" followed by 5 uppercase letters and a number (e.g. prs:FORBR1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="persName.dontUseRoleName" mode="add" scheme="schematron">
                     <desc>Do not use roleName, but use occupation instead.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName/tei:roleName">
                           <sch:assert test="false()">ERROR: Rolenames should not be denoted in a persName directly; all role information should be encoded using the occupation element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="person" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <macroRef key="lim.personMacro"/>
                     <!--Add linkGrp optionally only for person, not persona-->
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="person.constraints" scheme="schematron">
                     <desc>Various constraints for the different models for contributors and non-contributors.</desc>
                     <constraint>
                        <sch:rule context="/tei:person[not(@role='contributor')]">
                           <sch:assert test="matches(@xml:id,concat('^', $persIdPattern, '$'))">ERROR: All people must have an @xml:id of 5 uppercase letters and a number (e.g. FORBR1).</sch:assert>
                           <sch:assert test="tei:langKnowledge">ERROR: People must contain a langKnowledge element.</sch:assert>
                        </sch:rule>
                        <sch:rule context="/tei:person[@role='contributor']">
                           <sch:assert test="matches(@xml:id, '^[A-Z]{2,3}\d+$')">ERROR: All contributors must have an @xml:id of 2-3 uppercase letters and a number (e.g. LD1).</sch:assert>
                           <sch:assert test="tei:persName and tei:note">ERROR: Contributors should only contain persName and note.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="age" mode="delete"/>
                     <!--Remove @sex, since we use the element instead-->
                     <attDef ident="sex" mode="delete"/>
                     <attDef ident="role" mode="change">
                        <valList>
                           <valItem ident="contributor" mode="add">
                              <desc>contributor</desc>
                              <gloss>a contemporary contributor to the Lyon in Mourning project</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="persona" module="namesdates" mode="change">
                  <content>
                     <macroRef key="lim.personMacro"/>
                  </content>
               </elementSpec><elementSpec ident="place" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.rendition" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="att.global.source" mode="delete"/>
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                     <elementRef key="location" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="place.mustHaveProperId" scheme="schematron">
                     <desc>All people must have a proper id.</desc>
                     <constraint>
                        <sch:rule context="/tei:place">
                           <sch:assert test="matches(@xml:id,concat('^', $placeIdPattern, '$'))">ERROR: All places must have an @xml:id of 4 uppercase letters and a number (e.g. LEIT1).</sch:assert>
                           <sch:assert test="tei:placeName">ERROR: All places must have a placeName.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="placeName" module="namesdates" mode="change">
                  <constraintSpec ident="placeName.mustHaveRefWithPlc" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:placeName[not(parent::tei:place)][@ref] | tei:*[@where]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^plc:', $placeIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "plc:" followed by 4 uppercase letters and a number (e.g. plc:LEIT1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="residence" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <!--Add custom att.locatable-->
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.naming" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="sex" module="namesdates" mode="change">
                  <classes>
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="val" mode="change" usage="req"/>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="type" mode="delete"/>
                  </attList>
               </elementSpec><classSpec ident="att.datable.custom" module="namesdates" type="atts" mode="change">
                  <attList>
                     <attDef ident="datingPoint" mode="delete"/>
                  </attList>
               </classSpec>
               <moduleRef key="tei"/><classSpec ident="att.anchoring" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="targetEnd" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.breaking" type="atts" module="tei" mode="delete"/><classSpec ident="att.cReferencing" module="tei" type="atts" mode="delete"/><classSpec ident="att.canonical" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="key" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.damaged" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="group" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.datable" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="period" mode="delete"/>
                  </attList>
                  
               </classSpec><classSpec ident="att.datable.iso" module="tei" type="atts" mode="delete"/><classSpec ident="att.datcat" module="tei" type="atts" mode="delete"/><classSpec ident="att.declarable" module="tei" type="atts" mode="delete"/><classSpec ident="att.declaring" module="tei" type="atts" mode="delete"/><classSpec ident="att.divLike" module="tei" type="atts" mode="delete"/><classSpec ident="att.docStatus" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="status" mode="delete"/>
                     <attDef ident="docStatus" mode="add" usage="opt">
                        <desc versionDate="2010-05-06" xml:lang="en">describes the status of the transcription at the time indicated.</desc>
                        <valList type="closed" mode="add">
                           <valItem ident="empty" mode="add">
                              <desc>transcription empty</desc>
                              <gloss>empty / not yet worked on or edited</gloss>
                           </valItem>
                           <valItem ident="uneditedTranscription" mode="add">
                              <desc>Converted and unedited transcription</desc>
                              <gloss>The transcription has been converted from a word doc (or similar)
                              and has yet to be edited.</gloss>
                           </valItem>
                           <valItem ident="uneditedHTR" mode="add">
                              <desc>HTR transcription unedited</desc>
                              <gloss>transcription has not yet been edited from the conversion
                              from Transkribus</gloss>
                           </valItem>
                           <valItem ident="inProgress" mode="add">
                              <desc>transcription in progress</desc>
                              <gloss>currently being worked on, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="readyForProof" mode="add">
                              <desc>transcription ready for proof</desc>
                              <gloss>corrected and encoded, and is now ready to be proofed</gloss>
                           </valItem>
                           <valItem ident="proofed" mode="add">
                              <desc>transcription proofed</desc>
                              <gloss>proofed and checked</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="metaStatus" mode="add" usage="opt">
                        <desc versionDate="2010-05-06" xml:lang="en">describes the status of the metadata for a document at the time indicated.</desc>
                        <datatype>
                           <dataRef key="teidata.word"/>
                        </datatype>
                        <valList type="closed" mode="add">
                           <valItem ident="empty" mode="add">
                              <desc>metadata empty</desc>
                              <gloss>empty / not yet worked on or edited</gloss>
                           </valItem>
                           <valItem ident="inProgress" mode="add">
                              <desc>metadata in progress</desc>
                              <gloss>currently being worked on, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="done" mode="add">
                              <desc>metadata done</desc>
                              <gloss>Metadata work is completed</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.editLike" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="instant" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.edition" module="tei" type="atts" mode="delete"/><classSpec ident="att.fragmentable" module="tei" type="atts" mode="delete"/><classSpec ident="att.global" module="tei" type="atts" mode="change">
                  <classes mode="change">
              <!--Remove facs and responsibility from the global modules,
                so we can add them on the individual elements that we need-->
                     <memberOf key="att.global.facs" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="delete"/>
                     <memberOf key="att.global.linking" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="lim.att.global.fragmentable" mode="add"/>
                  </classes>
                  <constraintSpec ident="allIdsMustBeUnique" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           
                           <sch:rule context="*[@xml:id]">
                              <sch:let name="allIds" value="//*[@xml:id]/@xml:id"/>
                              <sch:let name="myId" value="@xml:id"/>
                              
                              <sch:assert test="count($allIds[. = $myId]) = 1">ERROR: Duplicate id found <sch:value-of select="$myId"/></sch:assert>
                           </sch:rule>
                         
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
              <!--We'll never need space or base, afaik-->
                     <attDef ident="xml:space" mode="delete"/>
                     <attDef ident="xml:base" mode="delete"/>
                  </attList>
                  
               </classSpec><classSpec ident="att.global.analytic" type="atts" mode="change">
                  <constraintSpec ident="att.global.analytic.distinctValues" scheme="schematron">
                     <desc><att>ana</att> values should all be distinct</desc>
                     <constraint>
                        <sch:rule context="*[@ana]">
                           <sch:let name="values" value="tokenize(@ana,'\s+')"/>
                           <sch:let name="dups" value="for $v in $values return if (count(index-of($values, $v)) gt 1) then $v else ()"/>
                           <sch:assert test="empty($dups)">
                              ERROR: Do not repeat @ana values (duplicate values found: <sch:value-of select="string-join(distinct-values($dups),', ')"/>)
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="ana" mode="change">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="limdata.ana"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.global.facs" type="atts" mode="change">
                  <!--Restrict the use of @facs to only allow lib:-->
                  <attList>
                     <attDef ident="facs" mode="change">
                        <datatype maxOccurs="1">
                           <dataRef key="limdata.facs"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The facs attribute should contain only a single pointer of the limdata.facs.</p>
                  </remarks>
               </classSpec><classSpec ident="att.global.linking" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="synch" mode="delete"/>
                     <attDef ident="sameAs" mode="delete"/>
                     <attDef ident="next" mode="delete"/>
                     <attDef ident="prev" mode="delete"/>
                     <attDef ident="exclude" mode="delete"/>
                     <attDef ident="select" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.global.rendition" module="tei" type="atts" mode="change">
                  <constraintSpec scheme="schematron" ident="rendition.onlyInBornDigital" mode="add">
                     <desc>Constraints for renditions that should only be used in
                     born digital documents</desc>
                     <constraint>
                        <sch:rule context="tei:*[contains-token(@rendition,'rnd:hidden')]">
                           <sch:assert test="self::tei:head and ancestor::tei:TEI/descendant::tei:catRef[matches(@target,'bornDigital')]">ERROR: rnd:hidden is meant only for born digital document headings.</sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <attList>
              <!--Delete @rend, since it's too ambiguous to be useful-->
                     <attDef ident="rend" mode="delete"/>
                     <!--Delete style unless we think that's important-->
                     <attDef ident="style" mode="delete"/>
                     <!--And constraint rendition-->
                     <attDef ident="rendition" mode="change">
                        <constraintSpec ident="rendition.twoColumnNeedsLeftAndRight" scheme="schematron" mode="add">
                           <desc>The two column layout requires one item to be left and one item to be right.</desc>
                           <constraint>
                              <sch:rule context="tei:*[contains-token(@rendition,'rnd:two-column')]">
                                 <sch:let name="children" value="child::tei:*"/>
                                 <sch:let name="leftChild" value="$children[contains-token(@rendition,'rnd:left')]"/>
                                 <sch:let name="rightChild" value="$children[contains-token(@rendition, 'rnd:right')]"/>
                                 <sch:assert test="exists($children) and (count(($leftChild, $rightChild)) = count($children))">ERROR: Every child of a two column layout must have either a rnd:right or a rnd:left rendition value.</sch:assert>
                                 <sch:assert test="exists($leftChild) and exists($rightChild)">ERROR: There must be at least one rnd:left and one rnd:right child</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <constraintSpec ident="rendition.mutualExclusion" scheme="schematron" mode="add">
                           <desc>Some renditions contradict each other</desc>
                           <constraint>
                              <sch:rule context="tei:*[@rendition]">
                                 <sch:let name="rendition" value="@rendition"/>
                                 <sch:let name="ptrs" value="tokenize(@rendition,'\s+')"/>
                                 <sch:let name="tokens" value="for $p in $ptrs return substring-after($p,'rnd:')"/>
                                 <sch:let name="duplicates" value="$tokens[count(index-of($tokens, .)) gt 1]"/>
                                 <sch:assert test="empty($duplicates)">ERROR: Duplicate renditions found: <sch:value-of select="string-join($duplicates,', ')"/>. Do not use the same rendition more than once on a single element.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('left','right','center')]) lt 2">ERROR: rnd:right, rnd:left, or rnd:center are mutually exclusive.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('large','small')]) lt 2">ERROR: rnd:large and rnd:small are mutually exclusive.</sch:assert>
                                 <sch:assert test="count($tokens[. = ('bordered-bottom','bordered-bottom-dashed')]) lt 2">ERROR: rnd:bordered-bottom and rnd:bordered-bottom-dashed are mutually exclusive.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <valList type="closed" mode="add"><valItem ident="rnd:super"><desc>super</desc><gloss>Superscript</gloss></valItem><valItem ident="rnd:sub"><desc>sub</desc><gloss>Subscript</gloss></valItem><valItem ident="rnd:underlined"><desc>underlined</desc><gloss>Underlined</gloss></valItem><valItem ident="rnd:right-braced"><desc>right-braced</desc><gloss>Right braced</gloss></valItem><valItem ident="rnd:bordered-all"><desc>bordered-all</desc><gloss>Bordered on all four sides</gloss></valItem><valItem ident="rnd:bordered-left"><desc>bordered-left</desc><gloss>Left bordered</gloss></valItem><valItem ident="rnd:bordered-right"><desc>bordered-right</desc><gloss>Right bordered</gloss></valItem><valItem ident="rnd:bordered-bottom"><desc>bordered-bottom</desc><gloss>Bottom bordered</gloss></valItem><valItem ident="rnd:bordered-bottom-dashed"><desc>bordered-bottom-dashed</desc><gloss>Bottom bordered</gloss></valItem><valItem ident="rnd:bordered-top"><desc>bordered-top</desc><gloss>Top bordered</gloss></valItem><valItem ident="rnd:bold"><desc>bold</desc><gloss>Bold</gloss></valItem><valItem ident="rnd:indent-first-line"><desc>indent-first-line</desc><gloss>Indent</gloss></valItem><valItem ident="rnd:indent-block"><desc>indent-block</desc><gloss>Indented block</gloss></valItem><valItem ident="rnd:overline"><desc>overline</desc><gloss>Overline</gloss></valItem><valItem ident="rnd:small"><desc>small</desc><gloss>Small text</gloss></valItem><valItem ident="rnd:large"><desc>large</desc><gloss>Larger text (i.e. headings)</gloss></valItem><valItem ident="rnd:strikethrough"><desc>strikethrough</desc><gloss>Strikethrough</gloss></valItem><valItem ident="rnd:normal"><desc>normal</desc><gloss>Normal</gloss></valItem><valItem ident="rnd:left"><desc>left</desc><gloss>Left aligned</gloss></valItem><valItem ident="rnd:right"><desc>right</desc><gloss>Right aligned</gloss></valItem><valItem ident="rnd:center"><desc>center</desc><gloss>Centered</gloss></valItem><valItem ident="rnd:embellished"><desc>embellished</desc><gloss>Embellished letter</gloss></valItem><valItem ident="rnd:two-column"><desc>two-column</desc><gloss>A block that has two columns</gloss></valItem><valItem ident="rnd:rotate-left"><desc>rotate-left</desc><gloss>A block rotated -90 degrees.</gloss></valItem><valItem ident="rnd:rotate-right"><desc>rotate-right</desc><gloss>A block rotated 90 degrees.</gloss></valItem></valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.naming" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="nymRef" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.notated" module="tei" type="atts" mode="delete"/><classSpec ident="att.personal" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="full" mode="delete"/>
                     <attDef ident="sort" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.placement" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="place" mode="change">
                        <datatype>
                           <dataRef key="limdata.placement"/>
                        </datatype>
                        <valList mode="delete"/>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.pointing" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="targetLang" mode="delete"/>
                     <attDef ident="evaluate" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.pointing.group" mode="delete" module="tei" type="atts"/><classSpec ident="att.segLike" module="tei" mode="change" type="atts">
                  <attList>
                     <attDef ident="function" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.sortable" module="tei" type="atts" mode="delete"/><classSpec ident="att.timed" module="tei" type="atts" mode="delete"/><classSpec ident="att.transcriptional" module="tei" type="atts" mode="delete"/><classSpec ident="att.typed" module="tei" type="atts" mode="change">
                  <attList>
              <!--Remove subtype for now-->
                     <attDef ident="subtype" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.written" module="tei" type="atts" mode="change">
                  <constraintSpec scheme="schematron" ident="hand.ForbesOnlyIfImmediateHandIsnt">
                     <desc>The use of Forbes' hand makes no sense unless the hand is someone else's.</desc>
                     <constraint>
                        <sch:rule context="tei:*[@hand = 'hand:Forbes']">
                           <sch:let name="ancHand" value="ancestor::*[1][@hand]/@hand"/>
                           <sch:assert test="exists($ancHand) and not($ancHand = 'hand:Forbes')">ERROR: Specifying hand:Forbes rarely makes sense since his is the implied hand in all cases; the value hand:Forbes should only be used when the hand has switched from Forbes to another hand and then back to Forbes.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="hand" mode="change">
                        
                     <valList type="closed" mode="add"><valItem ident="hand:Forbes"><gloss>Forbes</gloss><desc>Forbes' hand</desc></valItem><valItem ident="hand:Chambers"><gloss>Chambers</gloss><desc>Chambers' hand, written in pencil</desc></valItem><valItem ident="hand:unknown"><gloss>unknown</gloss><desc>An unknown hand that is neither Chambers or Forbes.</desc></valItem></valList></attDef>
                  </attList>
               </classSpec><dataSpec module="tei" ident="teidata.language" mode="change">
                  <content>
                     <alternate>
                        <dataRef name="language"/>
                        <!--Add the subset of languages we know we might use
                  so far-->
                        <valList mode="add" type="semi">
                           <valItem ident="la">
                              <desc>la</desc>
                              <gloss>Latin</gloss>
                           </valItem>
                           <valItem ident="en">
                              <desc>en</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="fr">
                              <desc>fr</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="gr">
                              <desc>gr</desc>
                              <gloss>Greek</gloss>
                           </valItem>
                           <valItem ident="ga">
                              <desc>ga</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="gd">
                              <desc>gd</desc>
                              <gloss>Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="de">
                              <desc>de</desc>
                              <gloss>German</gloss>
                           </valItem>
                           <valItem ident="es">
                              <desc>es</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="sco">
                              <desc>sco</desc>
                              <gloss>Scots</gloss>
                           </valItem>
                           <valItem ident="ghc">
                              <desc>ghc</desc>
                              <gloss>Hiberno-Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="it">
                              <desc>it</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                        </valList>
                     </alternate>
                  </content>
               </dataSpec>
               <moduleRef key="textstructure" include="TEI body byline closer dateline div docAuthor docDate docEdition docImprint docTitle epigraph front imprimatur opener postscript salute signed text titlePage titlePart trailer"/><elementSpec ident="closer" module="textstructure" mode="change">
                  <content>
                     <macroRef key="lim.macro.openerAndCloserContent"/>
                  </content>
               </elementSpec><elementSpec ident="div" mode="change" module="textstructure">
                  <constraintSpec ident="div.onlyRootWithIndexAndVolume11" scheme="schematron" mode="add">
                     <desc>Only index divs are allowed as a root div element and only for vol 11.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="/tei:div">
                              <sch:assert test="@type = 'index'">ERROR: Only divisions with @type='index' are allowed
                      as root elements.</sch:assert>
                              <sch:assert test="matches($uri,'vol11_')">ERROR: Only use root divs for volume 11.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList mode="add" type="closed">
                           <valItem ident="index">
                              <gloss>index</gloss>
                              <desc>An index/table of contents for a single volume.</desc>
                           </valItem>
                           <valItem ident="preface">
                              <gloss>preface</gloss>
                              <desc>A preface or some prefatory matter to a volume or text.</desc>
                           </valItem>
                           <valItem ident="footnotes">
                              <gloss>footnotes</gloss>
                              <desc>A set of footnotes</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="item" mode="change" module="textstructure">
                  <constraintSpec ident="item.indexItemsMustHaveTitleAndNum" scheme="schematron" mode="add">
                     <desc>All index items must contain a title and a number</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:div[@type='index']/tei:list/tei:item">
                              <sch:assert test="count(tei:num) gt 0">ERROR: All index items must contain at least one num element.</sch:assert>
                              <sch:assert test="count(descendant::tei:title) gt 0">ERROR: All index items must contain at least one title element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="opener" module="textstructure" mode="change">
                  <content>
                     <macroRef key="lim.macro.openerAndCloserContent"/>
                  </content>
               </elementSpec><macroSpec module="textstructure" ident="lim.macro.openerAndCloserContent">
                  <gloss>Openers and closers content</gloss>
                  <desc>A macro specification for openers and closers, since their content
                  models are fairly limited, but should be kept aligned.</desc>
                  <content>
                     <alternate minOccurs="1" maxOccurs="unbounded">
                        <elementRef key="signed"/>
                        <elementRef key="dateline"/>
                        <elementRef key="salute"/>
                        <classRef key="model.milestoneLike"/>
                     </alternate>
                  </content>
               </macroSpec>
               <moduleRef key="transcr" include="damage facsimile fw handNotes handShift metamark space subst supplied surface surfaceGrp zone"/><elementSpec ident="facsimile" module="transcr" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="fw" module="transcr" mode="change">
                  <constraintSpec ident="fw.pageNum.mustHavePlace" scheme="schematron">
                     <desc>All pageNum formeworks must have an @place</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:fw[@type=('pageNum', 'folioNum')]">
                              <sch:assert test="@place">ERROR: Missing required @place attribute for page number formework.</sch:assert>
                           </sch:rule>
                           <!--<sch:rule context="tei:fw[@type='catchword']">
                              <sch:let name="firstFollowingEl" value="following::tei:*[1]"/>
                              <sch:assert test="empty($firstFollowingEl) or $firstFollowingEl/self::tei:pb">ERROR: All catchwords should have a page beginning after</sch:assert>
                           </sch:rule>-->
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem ident="pageNum">
                              <gloss>page number</gloss>
                              <desc>A page number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                           <valItem ident="catchword">
                              <gloss>catchword</gloss>
                              <desc>A catchword, usually on the bottom right of the page.</desc>
                           </valItem>
                           <valItem ident="sig">
                              <gloss>signature</gloss>
                              <desc>A page signature, usually on the bottom center of the page.</desc>
                           </valItem>
                           <valItem ident="folioNum">
                              <gloss>folio number</gloss>
                              <desc>A folio number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="metamark" module="transcr" mode="change">
                  <!--Delete all class membership, since we don't want this appearing
                     anywhere but within ellipsis-->
                  <classes mode="replace"/>
                  <content>
                     <alternate minOccurs="1" maxOccurs="1">
                        <elementRef key="space"/>
                        <textNode/>
                     </alternate>
                  </content>
                  <constraintSpec ident="metamark.actualContentOrSpace" scheme="schematron">
                     <desc>All metamarks should contain actual content or the <gi>space</gi> element</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:metamark[not(tei:space)]">
                              <sch:assert test="matches(string(.),'\S')">ERROR: Metamarks must contain
                                 either text content or the &lt;space&gt; element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <remarks>
                     <p><gi>metamark</gi>s should only appear within the <gi>ellipsis</gi> element and should contain either 
                     meaningful text-content or the <gi>space</gi> element.</p>
                  </remarks>
               </elementSpec><elementSpec ident="space" module="transcr" mode="change">
                  <classes mode="replace"/>
                  <remarks>
                     <p>The <gi>space</gi> element should be used only within the <gi>metamark</gi> element (which itself is 
                     only used within the <gi>ellipsis</gi> element).</p>
                  </remarks>
                  
               </elementSpec><elementSpec ident="supplied" module="transcr" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.ranging" mode="delete"/>
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.editLike" mode="delete"/>
                  </classes>
               </elementSpec><classSpec ident="att.global.change" module="transcr" type="atts" mode="delete"/>
            </schemaSpec>
         </div>
      </back>
   </text>
</TEI>