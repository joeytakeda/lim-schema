<?xml version="1.0" encoding="UTF-8"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?><TEI xmlns="http://www.tei-c.org/ns/1.0" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xml:lang="en">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>Schema and Encoding Guidelines for the <title level="m">Lyon in Mourning</title> Project</title>
            <respStmt>
               <resp>Principle Investigator</resp>
               <name>Leith Davis</name>
            </respStmt>
         </titleStmt>
         <publicationStmt>
            <p>Probably free?</p>
         </publicationStmt>
         <sourceDesc>
            <p>No source; born digital.</p>
         </sourceDesc>
      </fileDesc>
      <encodingDesc>
         <classDecl>
            <taxonomy>
               <desc>Genre</desc>
               <category xml:id="letter">
                  <catDesc>
                     <term>letter</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="speech">
                  <catDesc>
                     <term>speech</term>
                     <gloss/>
                  </catDesc>
               </category>
               <category xml:id="conversation">
                  <catDesc>
                     <term>conversation</term>
                  </catDesc>
               </category>
               <category xml:id="accountNarrative">
                  <catDesc>
                     <term>account/narrative</term>
                  </catDesc>
               </category>
               <category xml:id="text">
                  <catDesc>
                     <term>text</term>
                  </catDesc>
                  <category xml:id="text_poem">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_song">
                     <catDesc>
                        <term>poem</term>
                     </catDesc>
                  </category>
                  <category xml:id="text_epitaph">
                     <catDesc>
                        <term>epitaph</term>
                     </catDesc>
                  </category>
               </category>
               <category xml:id="insert">
                  <catDesc>
                     <term>insert</term>
                  </catDesc>
               </category>
               <category xml:id="misc">
                  <catDesc>
                     <term>Miscellaneous</term>
                  </catDesc>
               </category>
            </taxonomy>
         </classDecl>
         <tagsDecl>
            <rendition xml:id="rnd_code">
           font-family: monospace;
        </rendition>
         </tagsDecl>
         <listPrefixDef>
            <prefixDef ident="doc" matchPattern="(.+)(#.+)?" replacementPattern="$1.xml$2">
               <p>Mechanism for pointing to a document in the repository. E.g. <val>doc:vol11_vol1</val>.</p>
            </prefixDef>
            <prefixDef ident="islandora" matchPattern="(\d+)" replacementPattern="https://digital.lib.sfu.ca/islandora/object/lyoninmourning:$1">
               <p>Resolves links to SFU's Islandora collection for the Lyon in Mourning page images.</p>
            </prefixDef>
            <prefixDef ident="lib" matchPattern="(\d+)" replacementPattern="#sfu_pg_$1">
               <p>Resolves links from a page in a volume to a facsimile element.</p>
            </prefixDef>
            <prefixDef ident="prs" matchPattern="(.+)" replacementPattern="people.xml#$1">
               <p>Resolves links to a person to the personography.</p>
            </prefixDef>
            <prefixDef ident="plc" matchPattern="(.+)" replacementPattern="places.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="org" matchPattern="(.+)" replacementPattern="organizations.xml#$1">
               <p>Resolves links to a place to the geography.</p>
            </prefixDef>
            <prefixDef ident="obj" matchPattern="(.+)" replacementPattern="objects.xml#$1">
               <p>Resolves links to an object to the object database.</p>
            </prefixDef>
            <prefixDef ident="bibl" matchPattern="(.+)" replacementPattern="bibliography.xml$1">
               <p>Resolves links to a bibliographic item.</p>
            </prefixDef>
         </listPrefixDef>
      </encodingDesc>
   </teiHeader>
   <text>
      <front>
         <div>
            <head>Encoding Guidelines</head>
            <p>This document serves as the documentation for <title level="m">The Lyon in Mourning: Networking Jacobites</title> (LiM). At the moment, what follows is a collection of notes to help with planning the project's structure and workflow; as decisions are made and plans are concretized, this document will be updated to reflect the actual encoding principles and guidelines.</p>
         </div>
      </front>
      <body>
         <div>
            <divGen xml:id="index"/>
         </div>
      </body>
      <back>
         <div>
            <head>Appendix</head>
            <schemaSpec ident="lim" start="TEI div person place org biblStruct" source="tei:4.2.2">
               <moduleRef key="analysis" include="pc"/><elementSpec ident="pc" mode="change" module="analysis">
            <!--Remove all other attributes-->
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.segLike" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <content>
                     <textNode/>
                  </content>
                  <constraintSpec ident="pc.onlyPunct" scheme="schematron" mode="add">
                     <desc>Only punctuation in pc.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:pc">
                           <sch:assert test="matches(text(),'^[\p{P}=]$')">ERROR: Only a single punctuation character is allowed in pc</sch:assert>
                           <sch:assert test="following-sibling::node()[1][self::tei:lb]">ERROR: All pc elements must be followed immediately by an lb element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="unit" mode="delete"/>
                     <attDef ident="pre" mode="delete"/>
                     <attDef ident="force" mode="change" usage="req"/>
                  </attList>
               </elementSpec><classSpec ident="att.linguistic" module="analysis" type="atts" mode="delete"/>
               
               <moduleRef key="core" include="abbr author bibl biblStruct choice corr date del desc divGen editor emph expan foreign gap gloss graphic head hi imprint item l label lb lg list listBibl mentioned milestone name note noteGrp num orig p pb ptr pubPlace publisher quote ref reg resp respStmt rs sic term time title unclear"/><elementSpec ident="pb" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.facs" mode="add"/>
                  </classes>
                  <attList>
                <!--Make @facs required-->
                     <attDef ident="facs" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="name" module="core" mode="change">
                  <constraintSpec ident="name.notForPeopleOrPlaces" mode="change" scheme="schematron">
                     <desc>Name should only be used if there isn't a more specific element.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:name[@ref]">
                           <sch:assert test="not(matches(@ref,'^prs:'))">ERROR: Use &lt;persName&gt; to tag names of people.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^plc:'))">ERROR: Use &lt;placeName&gt; to tag names of places.</sch:assert>
                           <sch:assert test="not(matches(@ref,'^org:'))">ERROR: Use &lt;orgName&gt; to tag names of organizations.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="opt">
                        <valList type="closed" mode="add">
                           <valItem ident="event" mode="add">
                              <gloss>event</gloss>
                              <desc>The name of an event (e.g. "The Battle of Prestonpans")</desc>
                           </valItem>
                           <valItem ident="object" mode="add">
                              <gloss>object</gloss>
                              <desc>The name of an object (e.g. "Excalibur")</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="rs" module="core" mode="change">
                  <constraintSpec ident="rs.familyNoRef" mode="change" scheme="schematron">
                     <desc>Family references should not have a ref.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:rs[@type='family']">
                           <sch:assert test="not(@ref)">ERROR: Do not use a @ref attribute on for a family reference since it can't point to anything.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="change">
                           <valItem mode="add" ident="person">
                              <gloss>person</gloss>
                              <desc>An indirect reference to a person (e.g. "his father"); use &lt;persName&gt; for direct references (i.e. "John Smith").</desc>
                           </valItem>
                           <valItem mode="add" ident="event">
                              <gloss>event</gloss>
                              <desc>An indirect reference to an event (e.g. "the day"); use &lt;name type="event"&gt; for direct references to events.</desc>
                           </valItem>
                           <valItem mode="add" ident="place">
                              <gloss>place</gloss>
                              <desc>An indirect reference to a place (e.g. "over there"); use &lt;placeName&gt; for direct references to places (i.e. "Edinburgh").</desc>
                           </valItem>
                           <valItem mode="add" ident="object">
                              <gloss>object</gloss>
                              <desc>An indirect reference to an object (e.g. "that thing"); use &lt;name type="object"&gt; for direct references to objects (i.e. "Excalibur").</desc>
                           </valItem>
                           <valItem mode="add" ident="family">
                              <gloss>family</gloss>
                              <desc>An reference to a family (e.g. "To my family").</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="lb" module="core" mode="change">
                  <constraintSpec ident="lb.noSpaces" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:lb[preceding-sibling::node()[1][self::tei:pc]]">
                           <sch:assert test="matches(following::text()[1],'^\S')">ERROR: All punctuation separated words in lines should not have any spaces after the line beginning element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="corr" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.transcriptional, since it should only be in <choice>-->
                     <memberOf key="model.pPart.transcriptional" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="expan" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.editorial, since it should only be in <choice>-->
                     <memberOf key="model.pPart.editorial" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="sic" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.transcriptional, since it should only be in <choice>-->
                     <memberOf key="model.pPart.transcriptional" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="note" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.pointer" mode="delete"/>
                  </classes>
                  <constraintSpec ident="note.co-occurence" scheme="schematron">
                     <desc>Various co-occurence constraints</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[@type='marginalia']">
                              <sch:assert test="@place">ERROR: All marginalia must have an @place.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="note.mustHaveTypeInText" scheme="schematron">
                     <desc>Notes must be typed in the body</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note[ancestor::tei:text]">
                              <sch:assert test="@type">ERROR: All notes in transcriptions must have a @type.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="opt">
                        <valList type="closed">
                           <valItem ident="editorial">
                              <gloss>editorial note</gloss>
                              <desc>An editorial note written by a team member.</desc>
                           </valItem>
                           <valItem ident="marginalia">
                              <gloss>marginalia</gloss>
                              <desc>A note that's not a footnote, but is some sort of marginal note.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="noteGrp" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="lim.att.boolean" mode="add"/>
                  </classes>
                  <content>
                     <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="quote" module="core" mode="change">
                  <classes mode="change">
                     <memberOf key="att.citing"/>
                  </classes>
               </elementSpec><elementSpec ident="abbr" module="core" mode="change">
                  <classes mode="change">
              <!--Remove from pPart.editorial, since it should only be in <choice>-->
                     <memberOf key="model.pPart.editorial" mode="delete"/>
                     <!--Add cert and resp-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <constraintSpec ident="abbr.shouldntContainJustAmp" scheme="schematron" mode="add">
                     <desc>Don't expand the ampersand only.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:abbr">
                           <sch:let name="content" value="string(.)"/>
                           <sch:assert test="not(matches($content, '^\s*&amp;\s*$'))">ERROR: There is no need to tag ampersands when it means "and".</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               
               <moduleRef key="corpus"/><elementSpec ident="settingDesc" module="corpus" mode="change">
                  <content>
                     <elementRef key="setting" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="setting" module="corpus" mode="change">
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:setting[ancestor::tei:limItem[matches(@type,'speech')]]">
                              <sch:assert test="tei:scaffold">
                      ERROR: All speeches must have a scaffold element.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               
               <moduleRef key="header" include="abstract catDesc catRef category change correspAction correspContext correspDesc encodingDesc fileDesc handNote idno listChange listPrefixDef notesStmt prefixDef profileDesc projectDesc publicationStmt rendition revisionDesc sourceDesc tagsDecl taxonomy teiHeader textClass titleStmt"/><elementSpec ident="correspAction" module="header" mode="change">
                  <classes mode="change">
                     <memberOf key="att.datable" mode="add"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.ascribed" mode="add"/>
                  </classes>
                  <content>
              <!--Allow for empty content-->
                     <alternate>
                        <classRef key="model.correspActionPart" minOccurs="0" maxOccurs="unbounded"/>
                        <classRef key="model.pLike" minOccurs="0" maxOccurs="unbounded"/>
                     </alternate>
                  </content>
               </elementSpec><elementSpec ident="change" mode="change" module="header">
                  <constraintSpec ident="changeMustPointToTeam" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:change">
                              <sch:assert test="every $ptr in tokenize(@who,'\s+') satisfies matches($ptr,'^team:')">
                      ERROR: Every pointer in change/@who must start with 'team:'.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="status" mode="change" usage="req"/>
                     <attDef ident="who" mode="change" usage="req"/>
                     <attDef ident="when" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="profileDesc" module="header" mode="change">
                  <content>
              <!--Must have a textClass-->
                     <elementRef key="locus" minOccurs="1" maxOccurs="2"/>
                     <elementRef key="abstact" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="limItem"/>
                  </content>
               </elementSpec><elementSpec ident="revisionDesc" mode="change" module="header">
                  <content>
                     <elementRef key="change" minOccurs="1" maxOccurs="unbounded"/>
                  </content>
                  <constraintSpec ident="revisionDescStatusMustMatch" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[@status]">
                              <sch:let name="thisStatus" value="@status"/>
                              <sch:let name="firstChange" value="tei:change[@status][1]"/>
                              <sch:assert test="$firstChange/@status = $thisStatus">
                      ERROR: The status attribute must match the @status of the latest change element.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="revisionDescEarliest" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:revisionDesc[count(tei:change[@when]) gt 1]">
                              <sch:let name="firstChange" value="tei:change[1]"/>
                              <sch:let name="secondChange" value="tei:change[2]"/>
                              <sch:let name="firstDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:let name="secondDate" value="xs:date(string-join((tokenize($firstChange/@when,'-'),'01','01')[position() lt 4],'-'))"/>
                              <sch:assert test="($firstDate gt $secondDate) or ($firstDate = $secondDate)">
                      ERROR: Change elements should be ordered reverse chronologically (latest first).
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="status" mode="change" usage="req"/>
                  </attList>
               </elementSpec><elementSpec ident="textClass" module="header" mode="change">
            <!--Add constraints to force either a correspDesc or a settingDesc-->
          </elementSpec>
               
               <elementSpec ident="listQuote" module="lim" mode="add">
                  <gloss>list of quotations</gloss>
                  <desc>contains a list of quotations from the item</desc>
                  <content>
                     <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="limItem" module="lim" mode="add">
                  <desc>contains a set of descriptional elements for a text that serves as the basis for a containing text.</desc>
                  <classes>
                     <memberOf key="att.typed"/>
                  </classes>
                  <content>
                     <sequence preserveOrder="false">
                        <alternate>
                           <elementRef key="correspDesc" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="settingDesc" minOccurs="0" maxOccurs="1"/>
                        </alternate>
                        <elementRef key="noteGrp" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="author" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="limItem" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="bibl" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList type="closed" mode="add">
                           <valItem ident="poemSongEpitaph" mode="add">
                              <desc>poemSongEpitaph</desc>
                              <gloss>poemSongEpitaph</gloss>
                           </valItem>
                           <valItem ident="letter" mode="add">
                              <desc>letter</desc>
                              <gloss>letter</gloss>
                           </valItem>
                           <valItem ident="accountNarrative" mode="add">
                              <desc>accountNarrative</desc>
                              <gloss>accountNarrative</gloss>
                           </valItem>
                           <valItem ident="speech" mode="add">
                              <desc>speech</desc>
                              <gloss>speech</gloss>
                           </valItem>
                           <valItem ident="conversation" mode="add">
                              <desc>conversation</desc>
                              <gloss>conversation</gloss>
                           </valItem>
                           <valItem ident="insert" mode="add">
                              <desc>insert</desc>
                              <gloss>insert</gloss>
                           </valItem>
                           <valItem ident="misc" mode="add">
                              <desc>misc</desc>
                              <gloss>misc</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="compliment" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec ident="request" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec ident="requests" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="request" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="duration" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                  </classes>
                  <content>
                     <macroRef key="macro.paraContent"/>
                  </content>
               </elementSpec><elementSpec ident="scaffold" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:scaffold[@value = 'true']">
                              <sch:assert test="tei:placeName">
                      ERROR: If this is a scaffold speech, then it must have a placeName associated
                      for the location of the trial.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="value">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="compliments" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="compliment" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><elementSpec ident="enclosure" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec><elementSpec ident="enclosures" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="enclosure" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec><classSpec ident="att.global.facs" type="atts" mode="change">
            <!--Restrict the use of @facs to only allow lib:-->
                  <attList>
                     <attDef ident="facs" mode="change">
                        <datatype maxOccurs="1">
                           <dataRef name="token" restriction="lib:\d+"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The facs attribute should contain only a single pointer of the form lib:\d+ (i.e. lib: followed by 1 or more digit).</p>
                  </remarks>
               </classSpec><constraintSpec scheme="schematron" ident="global.rootIdMustMatchDocument">
                  <desc>The rootid must be the same as the document's name.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:*">
                           <sch:let name="rootEl" value="local-name()"/>
                           <sch:let name="correctDir" value="                     if (self::tei:person and @role='contributor') then 'contributors'                     else if (self::tei:person) then 'people'                     else if (self::tei:place) then 'places'                     else if (self::tei:org) then 'orgs'                     else $dirName"/>
                           <sch:assert test="$basename = $id">
                    ERROR: Document's @xml:id (<sch:value-of select="$id"/>) must match the document's base filename
                    (<sch:value-of select="$basename"/>)
                  </sch:assert>
                           <sch:assert test="$dirName = $correctDir">
                    ERROR: All <sch:value-of select="if (self::person/@role) then @role else local-name()"/> files should added to the <sch:value-of select="$correctDir"/> folder. This file (<sch:value-of select="$id"/>) is in the <sch:value-of select="$dirName"/> folder.
                  </sch:assert>
                           <!--<sch:rule context="/tei:person[not(@role='contributor')]">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All people should be added to the /people/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:person[@role='contributor']">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All contributors should be added to the /contributors/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:org">
                    <sch:assert test="$dirName = 'orgs'">
                      ERROR: All orgs should be added to the /orgs/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:place">
                    <sch:assert test="$dirName = 'places'">
                      ERROR: All places should be added to the /places/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec scheme="schematron" ident="global.variables">
                  <desc>Global variables for use across the schematron.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:let name="id" value="/tei:*/@xml:id"/>
                        <sch:let name="uri" value="document-uri(/)"/>
                        <sch:let name="tokens" value="tokenize($uri,'[/\\]')"/>
                        <sch:let name="basename" value="replace($tokens[last()],'\.xm[l_]$','')"/>
                        <sch:let name="dirName" value="$tokens[last() - 1]"/>
                        <sch:let name="placeIdPattern" value="'[A-Z]{4}\d+'"/>
                        <sch:let name="orgIdPattern" value="'[A-Z]{4}\d+(_[^_]+)*'"/>
                        <sch:let name="persIdPattern" value="'[A-Z]{5}\d+'"/>
                        <sch:let name="cutoff" value="xs:date('1752-09-02')"/>
                        <!-- <sch:let name="pd" value="replace($uri,'^(.+[/\\]lim-tei[\\/]).+$', '$1')"/>
                <sch:let name="dataDir" value="replace($pd,'(.+(.))$','$1data$2')"/>
                <sch:let name="glyphs"
                  value="document($dataDir || 'glyphs.xml')//tei:glyph[@xml:id]"/> -->
                     </sch:pattern>
                  </constraint>
               </constraintSpec><constraintSpec scheme="schematron" ident="inlineElementsNoSpaces">
                  <desc>Inline elements should not begin or end with spaces.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:title | tei:num | tei:ref | tei:rs | tei:placeName[not(parent::tei:place)] | tei:persName[not(parent::tei:person)]">
                           <sch:let name="text" value="string(.)"/>
                           <sch:assert test="not(matches($text, '^\s+|\s+$'))">
                    ERROR: <sch:name/> should not begin or end with spaces.
                  </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec><moduleSpec ident="lim"/><classSpec ident="lim.att.boolean" mode="add" module="lim" type="atts">
                  <attList>
                     <attDef ident="value" usage="rec">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="lim.att.locatable" module="lim" type="atts" mode="add">
                  <attList>
                     <attDef ident="where" usage="opt">
                        <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec><macroSpec ident="lim.personMacro" module="lim" mode="add">
                  <content>
                     <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
                     <!--NOTE: preserveORder doesn't actually work, but there
                may be a new element coming: see
                https://github.com/TEIC/TEI/issues/2154 -->
                     <sequence preserveOrder="false">
                        <elementRef key="sex" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="birth" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="death" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="faith" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="affiliation" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="occupation" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="nationality" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="residence" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                     <!--Always make langKnowledge and note come last-->
                     <elementRef key="langKnowledge" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                  </content>
               </macroSpec><constraintSpec ident="metadataContraints" module="lim" mode="add" scheme="schematron">
                  <desc>Set of constraints for profileDesc / premediation.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:limItem">
                           <sch:let name="genre" value="@type"/>
                           <sch:assert test="if (matches($genre, 'letter','i')) then tei:correspDesc else true()">
                    ERROR: All letters must have a correspDesc.
                  </sch:assert>
                           <sch:assert test="if (matches($genre,'Speech|Account|Conversation','i')) then tei:settingDesc else true()">
                    ERROR: All <sch:value-of select="$genre"/> must have a settingDesc.
                  </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               
               <moduleRef key="linking" include="standOff linkGrp ptr"/><elementSpec ident="standOff" module="linking" mode="change">
                  <constraintSpec ident="standoff.elementsMustUseCopyOfORHaveAPersName" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:standOff/tei:*[not(self::tei:listQuote)]/tei:*[not(self::tei:head)]">
                              <sch:assert test="@copyOf or tei:*">
                      ERROR: <sch:name/> elements need either a @copyOf that points to an existing <sch:name/> OR content.
                    </sch:assert>
                              <sch:assert test="not(@copyOf and tei:*)">
                      ERROR: <sch:name/> elements should have either a <sch:name/>Name element OR a @copyOf, but not both.
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec>
               
               <moduleRef key="msdescription" include="locus"/>
               
               <moduleRef key="namesdates" include="addName affiliation birth death faith floruit forename genName langKnowledge langKnown listObject listOrg listPerson listPlace location nameLink nationality object objectName occupation org orgName persName person persona place placeName residence roleName sex surname"/><elementSpec ident="persName" module="namesdates" mode="change">
                  <constraintSpec ident="persName.mustHaveRefWithPrs" mode="add" scheme="schematron">
                     <desc>All inline persNames must have a ref that points to the personography db.</desc>
                     <constraint>
                 <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName[not(parent::tei:person)][@ref]">
                           <sch:assert test="matches(@ref,concat('^prs:', $persIdPattern, '$'))">ERROR: All persName pointers must have an @ref that begins with "prs:" followed by 5 uppercase letters and a number (e.g. prs:FORBR1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="persName.dontUseRoleName" mode="add" scheme="schematron">
                     <desc>Do not use roleName, but use occupation instead.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:persName/tei:roleName">
                           <sch:assert test="false()">ERROR: Rolenames should not be denoted in a persName directly; all role information should be encoded using the occupation element.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="affiliation" module="namesdates" mode="change">
                  <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdAndProperlyNested">
                     <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                     <constraint>
                        <sch:rule context="tei:affiliation[@type=('clan','army')]">
                           <sch:assert test="matches(@ref,'org:')">ERROR: All <sch:value-of select="@type"/> affiliations must have a @ref that points to the org for that <sch:value-of select="@type"/>.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList type="closed" mode="replace">
                           <valItem ident="clan" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                           <valItem ident="army" mode="add">
                              <desc>clan</desc>
                              <gloss>clan</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="placeName" module="namesdates" mode="change">
                  <constraintSpec ident="placeName.mustHaveRefWithPlc" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:placeName[not(parent::tei:place)][@ref] | tei:*[@where]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^plc:', $placeIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "plc:" followed by 4 uppercase letters and a number (e.g. plc:LEIT1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="orgName" module="namesdates" mode="change">
                  <constraintSpec ident="placeName.mustHaveRefWithPlc" mode="add" scheme="schematron">
                     <desc>All inline placeNames must have a ref that points to the place db.</desc>
                     <constraint>
                <!--TODO: Remove @ref once feasible-->
                        <sch:rule context="tei:orgName[not(parent::tei:org)][@ref]">
                           <sch:let name="ptr" value="(@ref, @where)[1]"/>
                           <sch:assert test="matches($ptr ,concat('^org:', $orgIdPattern, '$'))">ERROR: All <sch:name/> pointers must have an @<sch:value-of select="local-name($ptr)"/> that begins with "org:" followed by 4 uppercase letters and a number (e.g. org:CLAN1).</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="person" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <macroRef key="lim.personMacro"/>
                     <!--Add linkGrp optionally only for person, not persona-->
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="person.constraints" scheme="schematron">
                     <desc>Various constraints for the different models for contributors and non-contributors.</desc>
                     <constraint>
                        <sch:rule context="/tei:person[not(@role='contributor')]">
                           <sch:assert test="matches(@xml:id,concat('^', $persIdPattern, '$'))">ERROR: All people must have an @xml:id of 5 uppercase letters and a number (e.g. FORBR1).</sch:assert>
                           <sch:assert test="tei:langKnowledge">ERROR: People must contain a langKnowledge element.</sch:assert>
                        </sch:rule>
                        <sch:rule context="/tei:person[@role='contributor']">
                           <sch:assert test="matches(@xml:id, '^[A-Z]{2}\d+$')">ERROR: All contributors must have an @xml:id of 2 uppercase letters and a number (e.g. LD1).</sch:assert>
                           <sch:assert test="tei:persName and tei:note">ERROR: Contributors should only contain persName and note.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="age" mode="delete"/>
                     <!--Remove @sex, since we use the element instead-->
                     <attDef ident="sex" mode="delete"/>
                     <attDef ident="role" mode="change">
                        <valList>
                           <valItem ident="contributor" mode="add">
                              <desc>contributor</desc>
                              <gloss>a contemporary contributor to the Lyon in Mourning project</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="listObject" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="object" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPerson" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="person" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="listPlace" mode="change" module="namesdates">
                  <content>
                     <sequence>
                        <elementRef key="head" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="place" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec><elementSpec ident="birth" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="death" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="add"/>
                     <memberOf key="att.dimensions" mode="delete"/>
                     <memberOf key="att.naming" mode="delete"/>
                     <memberOf key="att.canonical" mode="delete"/>
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="place" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.rendition" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                     <memberOf key="att.global.analytic" mode="delete"/>
                     <memberOf key="att.global.source" mode="delete"/>
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="place.mustHaveProperId" scheme="schematron">
                     <desc>All people must have a proper id.</desc>
                     <constraint>
                        <sch:rule context="/tei:place">
                           <sch:assert test="matches(@xml:id,concat('^', $placeIdPattern, '$'))">ERROR: All people must have an @xml:id of 4 uppercase letters and a number (e.g. LEIT1).</sch:assert>
                           <sch:assert test="tei:placeName">ERROR: All places must have a placeName.</sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="residence" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                     <!--Add custom att.locatable-->
                     <memberOf key="lim.att.locatable" mode="add"/>
                     <memberOf key="att.naming" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="object" module="namesdates" mode="change">
                  <content>
                     <elementRef key="objectName" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <remarks mode="add">
                     <p>Our use of object is not TEI conformant, but the break is fairly
                trivial: where objectName is simply used
              instead of objectIdentifier/objectName.</p>
                  </remarks>
               </elementSpec><elementSpec ident="sex" module="namesdates" mode="change">
                  <classes>
                     <memberOf key="att.global" mode="delete"/>
                     <memberOf key="att.typed" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="val" mode="change" usage="req"/>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="type" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="langKnown" module="namesdates" mode="change">
                  <classes mode="change">
              <!--Add @cert and @resp explicitly-->
                     <memberOf key="att.global.responsibility" mode="add"/>
                  </classes>
                  <attList>
              <!--We do not specify level of fluency-->
                     <attDef ident="level" mode="delete"/>
                  </attList>
               </elementSpec><elementSpec ident="faith" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
                     <attDef ident="calendar" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="rel:ChurchOfScotland" mode="add">
                              <desc>Church of Scotland</desc>
                              <gloss>Church of Scotland</gloss>
                           </valItem>
                           <valItem ident="rel:Episcopalian" mode="add">
                              <desc>Episcopalian</desc>
                              <gloss>Episcopalian</gloss>
                           </valItem>
                           <valItem ident="rel:Anglican" mode="add">
                              <desc>Anglican</desc>
                              <gloss>Anglican</gloss>
                           </valItem>
                           <valItem ident="rel:RomanCatholic" mode="add">
                              <desc>Roman Catholic</desc>
                              <gloss>Roman Catholic</gloss>
                           </valItem>
                           <valItem ident="rel:BritishOrthodox" mode="add">
                              <desc>British Orthodox</desc>
                              <gloss>British Orthodox</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="nationality" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global" mode="delete"/>
                  </classes>
                  <attList>
              <!--Remove @role, which is provided by att.naming,
                but att.naming is a superset of att.canonical,
                which we want for ref.-->
                     <attDef ident="role" mode="delete"/>
                     <attDef ident="ref" mode="change" usage="req">
                        <valList type="closed" mode="add">
                           <valItem ident="ntl:English" mode="add">
                              <desc>English</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="ntl:French" mode="add">
                              <desc>French</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="ntl:Spanish" mode="add">
                              <desc>Spanish</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="ntl:Irish" mode="add">
                              <desc>Irish</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="ntl:Scottish" mode="add">
                              <desc>Scottish</desc>
                              <gloss>Scottish</gloss>
                           </valItem>
                           <valItem ident="ntl:Prussian" mode="add">
                              <desc>Prussian</desc>
                              <gloss>Prussian</gloss>
                           </valItem>
                           <valItem ident="ntl:Austrian" mode="add">
                              <desc>Austrian</desc>
                              <gloss>Austrian</gloss>
                           </valItem>
                           <valItem ident="ntl:Hanoverian" mode="add">
                              <desc>Hanoverian</desc>
                              <gloss>Hanoverian</gloss>
                           </valItem>
                           <valItem ident="ntl:Italian" mode="add">
                              <desc>Italian</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                           <valItem ident="ntl:Dutch" mode="add">
                              <desc>Dutch</desc>
                              <gloss>Dutch</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="org" module="namesdates" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
                  <content>
              <!--Orgs must have an orgName-->
                     <elementRef key="orgName" minOccurs="1" maxOccurs="unbounded"/>
                     <!--Also needs a note-->
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                     <!--And may include a ptrGrp-->
                     <elementRef key="linkGrp" minOccurs="0" maxOccurs="1"/>
                     <!--And may have a list of suborganizations below it-->
                     <elementRef key="listOrg" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <attList>
                     <attDef ident="xml:id" mode="change" usage="req">
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdAndProperlyNested">
                           <desc>orgs must have an xml:id that follows the 4 letters and digit pattern, but may be nested.</desc>
                           <constraint>
                              <sch:rule context="/tei:org">
                                 <sch:assert test="matches(@xml:id, concat('^', $orgIdPattern, '$'))">ERROR: All main orgs must have an id that is a sequence of four letter and a digit.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                        <constraintSpec scheme="schematron" ident="orgs.mustHaveXmlIdAndProperlyNested">
                           <desc>org ids must be inherited.</desc>
                           <constraint>
                              <sch:rule context="tei:org/tei:listOrg/tei:org">
                                 <sch:let name="parentId" value="ancestor::tei:org[1]/@xml:id"/>
                                 <sch:assert test="starts-with(@xml:id, $parentId)">ERROR: All sub organization ids must start with the id of its parent organization.</sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                     </attDef>
                  </attList>
               </elementSpec><elementSpec ident="langKnowledge" module="namesdates" mode="change">
                  <classes mode="replace">
                     <memberOf key="model.persStateLike"/>
                  </classes>
               </elementSpec><elementSpec ident="persona" module="namesdates" mode="change">
                  <content>
                     <macroRef key="lim.personMacro"/>
                  </content>
               </elementSpec><classSpec ident="att.datable.custom" module="namesdates" type="atts" mode="change">
                  <attList>
                     <attDef ident="datingPoint" mode="delete"/>
                  </attList>
               </classSpec>
               
               <moduleRef key="tei"/><classSpec ident="att.anchoring" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="targetEnd" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.breaking" type="atts" module="tei" mode="delete"/><classSpec ident="att.cReferencing" module="tei" type="atts" mode="delete"/><classSpec ident="att.canonical" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="key" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.coordinated" type="atts" module="tei" mode="delete"/><classSpec ident="att.damaged" type="atts" module="tei" mode="change">
                  <attList>
                     <attDef ident="group" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.datable" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="period" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.datable.iso" module="tei" type="atts" mode="delete"/><classSpec ident="att.datcat" module="tei" type="atts" mode="delete"/><classSpec ident="att.declarable" module="tei" type="atts" mode="delete"/><classSpec ident="att.declaring" module="tei" type="atts" mode="delete"/><classSpec ident="att.divLike" module="tei" type="atts" mode="delete"/><classSpec ident="att.docStatus" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="status" mode="change" usage="rec">
                        <valList mode="add">
                           <valItem ident="empty" mode="add">
                              <desc>empty</desc>
                              <gloss>empty/not yet worked on</gloss>
                           </valItem>
                           <valItem ident="metadataInProgress" mode="add">
                              <desc>metadata in progress</desc>
                              <gloss>currently being worked on, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="metadataDone" mode="add">
                              <desc>metadata done</desc>
                              <gloss>Metadata for this item has been completed</gloss>
                           </valItem>
                           <valItem ident="transcriptionInProgress" mode="add">
                              <desc>transcription in progress</desc>
                              <gloss>Transcription in progress, but not yet "done"</gloss>
                           </valItem>
                           <valItem ident="transcriptionDone" mode="add">
                              <desc>transcription done</desc>
                              <gloss>The transcription for this item has been completed</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.editLike" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="instant" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.edition" module="tei" type="atts" mode="delete"/><classSpec ident="att.global" module="tei" type="atts" mode="change">
                  <classes mode="change">
              <!--Remove facs and responsibility from the global modules,
                so we can add them on the individual elements that we need-->
                     <memberOf key="att.global.facs" mode="delete"/>
                     <memberOf key="att.global.responsibility" mode="delete"/>
                     <memberOf key="att.global.linking" mode="delete"/>
                  </classes>
                  <attList>
              <!--We'll never need space or base, afaik-->
                     <attDef ident="xml:space" mode="delete"/>
                     <attDef ident="xml:base" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.global.linking" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="synch" mode="delete"/>
                     <attDef ident="sameAs" mode="delete"/>
                     <attDef ident="next" mode="delete"/>
                     <attDef ident="prev" mode="delete"/>
                     <attDef ident="exclude" mode="delete"/>
                     <attDef ident="select" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.global.rendition" module="tei" type="atts" mode="change">
                  <attList>
              <!--Delete @rend, since it's too ambiguous to be useful-->
                     <attDef ident="rend" mode="delete"/>
                     <!--Delete style unless we think that's important-->
                     <attDef ident="style" mode="delete"/>
                     <!--And constraint rendition-->
                     <attDef ident="rendition" mode="change">
                        <valList type="closed" mode="add">
                           <valItem ident="rnd:super">
                              <desc>superscript</desc>
                              <gloss>superscript</gloss>
                           </valItem>
                           <valItem ident="rnd:sub">
                              <desc>subscript</desc>
                              <gloss>subscript</gloss>
                           </valItem>
                           <valItem ident="rnd:underlined">
                              <gloss>underlined</gloss>
                              <desc>underlined (NOTE: This should be used almost exclusively with emph or title)</desc>
                           </valItem>
                           <valItem ident="rnd:right-braced">
                              <gloss>right-braced</gloss>
                              <desc>An item that has a curly right brace.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.naming" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="nymRef" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.notated" module="tei" type="atts" mode="delete"/><classSpec ident="att.personal" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="full" mode="delete"/>
                     <attDef ident="sort" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.placement" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="place" mode="change">
                        <valList type="closed" mode="replace">
                           <valItem ident="left" mode="add">
                              <gloss>left</gloss>
                              <desc>in the left margin</desc>
                           </valItem>
                           <valItem ident="right" mode="add">
                              <gloss>right</gloss>
                              <desc>in the right margin</desc>
                           </valItem>
                           <valItem ident="above" mode="add">
                              <gloss>above</gloss>
                              <desc>above the line</desc>
                           </valItem>
                           <valItem ident="below" mode="add">
                              <gloss>below</gloss>
                              <desc>below the line</desc>
                           </valItem>
                           <valItem ident="inline" mode="add">
                              <gloss>inline</gloss>
                              <desc>an inline note</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec><classSpec ident="att.pointing" module="tei" type="atts" mode="change">
                  <attList>
                     <attDef ident="targetLang" mode="delete"/>
                     <attDef ident="evaluate" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.pointing.group" mode="delete" module="tei" type="atts"/><classSpec ident="att.segLike" module="tei" mode="change" type="atts">
                  <attList>
                     <attDef ident="function" mode="delete"/>
                  </attList>
               </classSpec><classSpec ident="att.sortable" module="tei" type="atts" mode="delete"/><classSpec ident="att.spanning" module="tei" type="atts" mode="delete"/><classSpec ident="att.timed" module="tei" type="atts" mode="delete"/><classSpec ident="att.transcriptional" module="tei" type="atts" mode="delete"/><classSpec ident="att.typed" module="tei" type="atts" mode="change">
                  <attList>
              <!--Remove subtype for now-->
                     <attDef ident="subtype" mode="delete"/>
                  </attList>
               </classSpec><dataSpec module="tei" ident="teidata.language" mode="change">
                  <content>
                     <alternate>
                        <dataRef name="language"/>
                        <!--Add the subset of languages we know we might use
                  so far-->
                        <valList mode="add" type="semi">
                           <valItem ident="la">
                              <desc>la</desc>
                              <gloss>Latin</gloss>
                           </valItem>
                           <valItem ident="en">
                              <desc>en</desc>
                              <gloss>English</gloss>
                           </valItem>
                           <valItem ident="fr">
                              <desc>fr</desc>
                              <gloss>French</gloss>
                           </valItem>
                           <valItem ident="gr">
                              <desc>gr</desc>
                              <gloss>Greek</gloss>
                           </valItem>
                           <valItem ident="ga">
                              <desc>ga</desc>
                              <gloss>Irish</gloss>
                           </valItem>
                           <valItem ident="gd">
                              <desc>gd</desc>
                              <gloss>Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="de">
                              <desc>de</desc>
                              <gloss>German</gloss>
                           </valItem>
                           <valItem ident="es">
                              <desc>es</desc>
                              <gloss>Spanish</gloss>
                           </valItem>
                           <valItem ident="sco">
                              <desc>sco</desc>
                              <gloss>Scots</gloss>
                           </valItem>
                           <valItem ident="ghc">
                              <desc>ghc</desc>
                              <gloss>Hiberno-Scottish Gaelic</gloss>
                           </valItem>
                           <valItem ident="it">
                              <desc>it</desc>
                              <gloss>Italian</gloss>
                           </valItem>
                        </valList>
                     </alternate>
                  </content>
               </dataSpec>
               
               <moduleRef key="textstructure" include="TEI body byline closer dateline div docAuthor docDate docEdition docImprint docTitle epigraph front imprimatur opener postscript salute signed titlePage titlePart text trailer"/><elementSpec ident="item" mode="change" module="textstructure">
                  <constraintSpec ident="item.indexItemsMustHaveTitleAndNum" scheme="schematron" mode="add">
                     <desc>All index items must contain a title and a number</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:div[@type='index']/tei:list/tei:item">
                              <sch:assert test="count(tei:num) gt 0">ERROR: All index items must contain at least one num element.</sch:assert>
                              <sch:assert test="count(descendant::tei:title) gt 0">ERROR: All index items must contain at least one title element.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
               </elementSpec><elementSpec ident="div" mode="change" module="textstructure">
                  <constraintSpec ident="div.onlyRootWithIndexAndVolume11" scheme="schematron" mode="add">
                     <desc>Only index divs are allowed as a root div element and only for vol 11.</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="/tei:div">
                              <sch:assert test="@type = 'index'">ERROR: Only divisions with @type='index' are allowed
                      as root elements.</sch:assert>
                              <sch:assert test="matches($uri,'vol11_')">ERROR: Only use root divs for volume 11.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList mode="add" type="closed">
                           <valItem ident="index">
                              <gloss>index</gloss>
                              <desc>An index/table of contents for a single volume.</desc>
                           </valItem>
                           <valItem ident="preface">
                              <gloss>preface</gloss>
                              <desc>A preface or some prefatory matter to a volume or text.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               
               <moduleRef key="transcr" include="damage facsimile fw handNotes handShift supplied surface surfaceGrp zone"/><elementSpec ident="facsimile" module="transcr" mode="change">
                  <classes mode="change">
                     <memberOf key="att.global.linking" mode="add"/>
                  </classes>
               </elementSpec><elementSpec ident="fw" module="transcr" mode="change">
                  <constraintSpec ident="fw.pageNum.mustHavePlace" scheme="schematron">
                     <desc>All pageNum formeworks must have an @place</desc>
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:fw[@type=('pageNum', 'folioNum')]">
                              <sch:assert test="@place">ERROR: Missing required @place attribute for page number formework.</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" mode="change" usage="req">
                        <valList mode="add" type="closed">
                           <valItem ident="pageNum">
                              <gloss>page number</gloss>
                              <desc>A page number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                           <valItem ident="catchword">
                              <gloss>catchword</gloss>
                              <desc>A catchword, usually on the bottom right of the page.</desc>
                           </valItem>
                           <valItem ident="sig">
                              <gloss>signature</gloss>
                              <desc>A page signature, usually on the bottom center of the page.</desc>
                           </valItem>
                           <valItem ident="folioNum">
                              <gloss>folio number</gloss>
                              <desc>A folio number, usually written on the top left or right hand sides of a page.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec><classSpec ident="att.global.change" module="transcr" type="atts" mode="delete"/>
               
                </schemaSpec>
         </div>
      </back>
   </text>
</TEI>