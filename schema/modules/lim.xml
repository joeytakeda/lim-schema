<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="https://tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0"
     xmlns:sch="http://purl.oclc.org/dsdl/schematron"
     xml:id="lim">
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>LiM Schema: lim</title>
         </titleStmt>
         <publicationStmt>
            <p>See lim.odd</p>
         </publicationStmt>
         <sourceDesc>
            <p>Born Digital.</p>
         </sourceDesc>
      </fileDesc>
   </teiHeader>
   <text>
      <body>
         <div>
            <head>lim</head>
            <schemaSpec ident="lim_lim">
               <moduleSpec ident="lim"/>
               <!--compliment-->
               <elementSpec ident="compliment" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec>
               <!--compliments-->
               <elementSpec ident="compliments" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="compliment" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec>
               <!--duration-->
               <elementSpec ident="duration" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                  </classes>
                  <content>
                     <macroRef key="macro.paraContent"/>
                  </content>
               </elementSpec>
               <!--enclosure-->
               <elementSpec ident="enclosure" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec>
               <!--enclosures-->
               <elementSpec ident="enclosures" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="enclosure" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec>
               <!--limItem-->
               <elementSpec ident="limItem" module="lim" mode="add">
                  <desc>contains a set of descriptional elements for a text that serves as the basis for a containing text.</desc>
                  <classes>
                     <memberOf key="att.typed"/>
                  </classes>
                  <content>
                     <sequence preserveOrder="false">
                        <alternate>
                           <elementRef key="correspDesc" minOccurs="0" maxOccurs="1"/>
                           <elementRef key="settingDesc" minOccurs="0" maxOccurs="1"/>
                        </alternate>
                        <elementRef key="creation" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="noteGrp" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="date" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="author" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="limItem" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="note" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="bibl" minOccurs="0" maxOccurs="1"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="type" mode="change">
                        <valList type="closed" mode="add">
                           <valItem ident="poemSongEpitaph" mode="add">
                              <gloss>poem / song / epitaph</gloss>
                              <desc>poem / song / epitaph</desc>
                           </valItem>
                           <valItem ident="letter" mode="add">
                              <desc>letter</desc>
                              <gloss>letter</gloss>
                           </valItem>
                           <valItem ident="accountNarrative" mode="add">
                              <desc>account / narrative</desc>
                              <gloss>account / narrative</gloss>
                           </valItem>
                           <valItem ident="speech" mode="add">
                              <desc>speech</desc>
                              <gloss>speech</gloss>
                           </valItem>
                           <valItem ident="conversation" mode="add">
                              <desc>conversation</desc>
                              <gloss>conversation</gloss>
                           </valItem>
                           <valItem ident="insert" mode="add">
                              <desc>insert</desc>
                              <gloss>insert</gloss>
                           </valItem>
                           <valItem ident="misc" mode="add">
                              <desc>miscellaneous</desc>
                              <gloss>miscellaneous</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               <!--NB-->
               <elementSpec ident="NB" mode="add" module="lim">
                  <gloss>nota bene</gloss>
                  <desc>groups together content that is marked as a nota bene.</desc>
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.written"/>
                     <memberOf key="model.divBottomPart"/>
                  </classes>
                  <content>
                     <sequence>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.divTopPart"/>
                        </alternate>
                        <classRef key="model.common"/>
                        <alternate minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.global"/>
                           <classRef key="model.common"/>
                        </alternate>
                        <sequence minOccurs="0" maxOccurs="unbounded">
                           <classRef key="model.divBottomPart"/>
                           <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                        </sequence>
                     </sequence>
                  </content>
                  <remarks>
                     <p>The <gi>NB</gi> element is modelled after the <gi>postscript</gi> element
                        as Forbes frequently uses NBs in multiple contexts (including as trailing 
                        content, or as the entirety of an element).</p>
                     <p>When a NB is used as the content of a footnote, 
                        wrap the <gi>NB</gi> in the <gi>note</gi>.</p>
                     <p>We assume that all <gi>NB</gi> elements are written by Forbes (i.e. the implied value of <att>resp</att> is prs:FORBR1).</p>
                  </remarks>
               </elementSpec>
               <!--noteMarker-->
               <elementSpec ident="noteMarker" mode="add" module="lim">
                  <classes>
                     <memberOf key="model.milestoneLike"/>
                  </classes>
                  <constraintSpec ident="noteMarker.mustHaveTargetInNote" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:note/tei:noteMarker | tei:note/tei:supplied/tei:noteMarker">
                              <sch:assert test="@target">ERROR: Note markers in a note should have a target
                                 pointing to the source note marker.</sch:assert>
                           </sch:rule>
                           <sch:rule context="tei:noteMarker[not(parent::tei:note)] | tei:noteMarker[not(parent::tei:supplied/parent::tei:note)]">
                              <sch:assert test="@xml:id">ERROR: Note markers in the body of text should 
                              have an xml:id identifying it. (This should be automatic if you use
                              the keyboard shortcut Command + Shift + N)</sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <!--Identical to the ref on glyph-->
                     <attDef ident="ref" usage="req">
                        <desc versionDate="2005-01-14" xml:lang="en">points to a description of the character or glyph intended.</desc>
                        <desc versionDate="2007-05-02" xml:lang="zh-TW">連結到該文字或字體的描述。</desc>
                        <desc versionDate="2008-04-05" xml:lang="ja">当該文字やグリフの解説を参照する．</desc>
                        <desc versionDate="2007-06-12" xml:lang="fr">pointe vers la description du caractère ou du glyphe
                            visé</desc>
                        <desc versionDate="2007-05-04" xml:lang="es">indica la descripción del carácter o pictograma dado.</desc>
                        <desc versionDate="2007-01-21" xml:lang="it">punta a una descrizione del carattere o glifo.</desc>
                        <datatype>
                           <dataRef key="limdata.glyph"/>
                        </datatype>
                     </attDef>
                     <attDef ident="annotation" usage="opt">
                        <desc>describes any penciled annotation surrounding this note marker</desc>
                        <valList type="closed">
                           <valItem ident="circle">
                              <gloss>circle</gloss>
                              <desc>circled in pencil</desc>
                           </valItem>
                           <valItem ident="strike">
                              <gloss>strike</gloss>
                              <desc>Struck out in pencil</desc>
                           </valItem>
                        </valList>
                        <remarks>
                           <p>This <att>annotation</att> attribute is something of a shortcut 
                           for the <gi>add</gi> element to better describe some kind of phenomena around
                           a note marker added by a later annotator.</p>
                        </remarks>
                     </attDef>
                     <attList org="choice">
                        <attDef ident="xml:id" usage="req">
                           <gloss versionDate="2007-07-02" xml:lang="en">identifier</gloss>
                           <gloss versionDate="2007-12-20" xml:lang="ko">확인소</gloss>
                           <gloss versionDate="2008-04-06" xml:lang="es">identificador</gloss>
                           <gloss versionDate="2008-03-30" xml:lang="fr">identifiant</gloss>
                           <gloss versionDate="2007-11-06" xml:lang="it">identificatore</gloss>
                           <gloss xml:lang="ja" versionDate="2019-06-08">識別子</gloss>
                           <desc versionDate="2005-10-10" xml:lang="en">provides a unique identifier for the element bearing the attribute.</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">속성을 포함하는 요소에 대한 고유한 확인소를 제공한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">提供一個獨特識別符碼，識別帶有該屬性的元素。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">当該要素にユニークな識別子を示す．</desc>
                           <desc versionDate="2009-05-25" xml:lang="fr">fournit un identifiant unique pour l'élément qui
                              porte l'attribut</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">proporciona un identificador único para el elemento
                              al cual se asocia el atributo.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">assegna un identificatore unico all'elemento a cui è
                              associato l'attributo</desc>
                           <datatype><dataRef name="ID"/></datatype>
                           <remarks versionDate="2005-10-10" xml:lang="en">
                              <p>The <att>xml:id</att> attribute may be used to specify a canonical reference for an
                                 element; see section <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="fr" versionDate="2007-06-12">
                              <p>L'attribut <att>xml:id</att> peut être employé pour indiquer une référence canonique pour
                                 un élément ; voir la section<ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="es" versionDate="2008-04-06">
                              <p>El atributo <att>xml:id</att> se puede utilizar para especificar una referencia canónica
                                 para un elemento; ver la sección <ptr target="#CORS"/>.</p>
                           </remarks>
                           <remarks xml:lang="ja" versionDate="2008-04-05">
                              <p> 当該属性<att>xml:id</att>は，属性の指示対象を示している．詳細 は<ptr target="#CORS"/>を参照のこと． </p>
                           </remarks>
                        </attDef>
                        <attDef ident="target" usage="req">
                           <desc versionDate="2010-05-02" xml:lang="en">specifies the destination of the reference by supplying one or more URI References</desc>
                           <desc versionDate="2007-12-20" xml:lang="ko">하나 혹은 다수의 URI 참조를 제시하여 참조의 목적지를 명시한다.</desc>
                           <desc versionDate="2007-05-02" xml:lang="zh-TW">用一個或多個統一資源識別符參照 (URI References) 來說明參照所指位置。</desc>
                           <desc versionDate="2008-04-05" xml:lang="ja">ひとつ以上のURIで，参照先を特定する．</desc>
                           <desc versionDate="2009-01-06" xml:lang="fr">précise la cible de la référence en donnant une ou
                              plusieurs références URI</desc>
                           <desc versionDate="2007-05-04" xml:lang="es">especifica la destinación de una referencia
                              proporcionando una o más referencias URI.</desc>
                           <desc versionDate="2007-01-21" xml:lang="it">specifica la destinazione di un riferimento, fornendo
                              uno o più riferimenti URI</desc>
                           <datatype maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
                           <remarks versionDate="2007-01-21" xml:lang="en"><p>One or more syntactically valid URI references, separated by whitespace. Because
                              whitespace is used to separate URIs, no whitespace is permitted inside a single URI. If a
                              whitespace character is required in a URI, it should be escaped with the normal mechanism,
                              e.g. <code>TEI%20Consortium</code>.</p></remarks>
                           <remarks versionDate="2007-01-21" xml:lang="fr"><p>Une ou plusieurs références URI syntaxiquement valables, séparée par
                              un espace. Puisqu'un espace  est employé pour séparer des URIs, aucun espace
                              n’est autorisé à l'intérieur d'un URI. Si un espace est requis dans un URI, il
                              faut le représenter avec une séquence d'échappement, comme par exemple 
                              <code>TEI%20Consortium</code>.</p></remarks>
                        </attDef>
                     </attList>
                  </attList>
                  
               </elementSpec>
              
               <!--request-->
               <elementSpec ident="request" module="lim" mode="add">
                  <classes>
                     <memberOf key="att.global"/>
                     <memberOf key="att.ascribed.directed"/>
                  </classes>
                  <content>
                     <macroRef key="macro.specialPara"/>
                  </content>
               </elementSpec>
               <!--requests-->
               <elementSpec ident="requests" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.correspDescPart"/>
                  </classes>
                  <content>
                     <elementRef key="request" minOccurs="0" maxOccurs="unbounded"/>
                  </content>
               </elementSpec>
               <!--scaffold-->
               <elementSpec ident="scaffold" module="lim" mode="add">
                  <classes>
                     <memberOf key="model.settingPart"/>
                     <memberOf key="lim.att.locatable"/>
                  </classes>
                  <content>
                     <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                  </content>
                  <constraintSpec ident="scaffold.mustHaveTrialPlace" scheme="schematron">
                     <constraint>
                        <sch:pattern>
                           <sch:rule context="tei:scaffold[@value = 'true']">
                              <sch:assert test="tei:placeName or @where">
                      ERROR: If this is a scaffold speech, then it must have a place associated
                      for the location of the execution (either using a @where or a child placeName element).
                    </sch:assert>
                           </sch:rule>
                        </sch:pattern>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="value">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                     <attDef ident="where" mode="change">
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <valList mode="add" type="semi">
                           <valItem ident="plc:TOWE1" mode="add">
                              <desc>Tower of London</desc>
                              <gloss>Tower of London</gloss>
                           </valItem>
                           <valItem ident="plc:KENN1" mode="add">
                              <desc>Kennington Common</desc>
                              <gloss>Kennington Common</gloss>
                           </valItem>
                           <valItem ident="plc:CARL2" mode="add">
                              <desc>Carlisle</desc>
                              <gloss>Carlisle</gloss>
                           </valItem>
                           <valItem ident="plc:BRAM1" mode="add">
                              <desc>Brampton</desc>
                              <gloss>Brampton</gloss>
                           </valItem>
                           <valItem ident="plc:PENR1" mode="add">
                              <desc>Penrith</desc>
                              <gloss>Penrith</gloss>
                           </valItem>
                           <valItem ident="plc:YORK1" mode="add">
                              <desc>York</desc>
                              <gloss>York</gloss>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               <!--topic-->
               <elementSpec ident="topic" module="lim" mode="add">
                  <desc>marks the beginning of a longer sequence of text pertaining to a topic or set of topics.</desc>
                  <classes>
                     <memberOf key="att.spanning"/>
                     <memberOf key="att.global.analytic"/>
                     <memberOf key="model.global.edit"/>
                  </classes>
                  <content>
                     <empty/>
                  </content>
                  <attList>
                     <attDef ident="xml:id" mode="delete"/>
                     <attDef ident="xml:space" mode="delete"/>
                     <attDef ident="spanTo" usage="req" mode="change"/>
                     <attDef ident="ana" usage="req" mode="change"/>
                  </attList>
                  <remarks>
                     <p>The <gi>topic</gi> element is a custom element for the LiM project to mark the beginning of an analytic segment; it should be used in concert with a <gi>anchor</gi> bearing an <att>xml:id</att>.</p>
                  </remarks>
               </elementSpec>
               <!--lim.att.boolean-->
               <classSpec ident="lim.att.boolean" mode="add" module="lim" type="atts">
                  <attList>
                     <attDef ident="value" usage="rec">
                        <datatype>
                           <dataRef key="teidata.xTruthValue"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec>
               <!--lim.att.global.fragmentable-->
               <classSpec ident="lim.att.global.fragmentable"
                          mode="add"
                          module="lim"
                          type="atts">
                  <desc versionDate="2021-08-22" xml:lang="en">provides attributes for representing
                     fragmentation of a structural element, typically as 
                     a consequence of some overlapping hierarchy.</desc>
                  <attList>
                     <attDef ident="part" usage="opt">
                        <desc versionDate="2013-06-21" xml:lang="en">specifies whether or not its parent element is fragmented
                           in some way, typically by some other overlapping structure: for
                           example a speech which is divided between two or more verse
                           stanzas, a paragraph which is split across a page division, a
                           verse line which is divided between two speakers.</desc>
                        <datatype>
                           <dataRef key="teidata.enumerated"/>
                        </datatype>
                        <valList type="closed">
                           <valItem ident="Y">
                              <gloss versionDate="2013-01-07" xml:lang="en">yes</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">はい</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is fragmented in some (unspecified) respect</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素はいくつかの（不特定の）点で断片化されている。</desc>
                           </valItem>
                           <valItem ident="N">
                              <gloss versionDate="2013-01-07" xml:lang="en">no</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">いいえ</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">the element is not fragmented, or no claim is made as to its completeness</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">要素が断片化されていないか，または完全性についての主張はない。</desc>
                           </valItem>
                           <valItem ident="I">
                              <gloss versionDate="2013-01-07" xml:lang="en">initial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最初の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the initial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最初の部分を示す。</desc>
                           </valItem>
                           <valItem ident="M">
                              <gloss versionDate="2013-01-07" xml:lang="en">medial</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">中間の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is a medial part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の中間の部分を示す。</desc>
                           </valItem>
                           <valItem ident="F">
                              <gloss versionDate="2013-01-07" xml:lang="en">final</gloss>
                              <gloss xml:lang="ja" versionDate="2019-06-08">最後の</gloss>
                              <desc versionDate="2013-01-07" xml:lang="en">this is the final part of a fragmented element</desc>
                              <desc xml:lang="ja" versionDate="2019-06-08">これは断片化された要素の最後の部分を示す。</desc>
                           </valItem>
                        </valList>
                        <remarks versionDate="2013-01-07" xml:lang="en">
                           <p>The values <val>I</val>, <val>M</val>, or <val>F</val>
                              should be used only where it is clear how the element may
                              be reconstituted.</p>
                        </remarks>
                        <remarks xml:lang="ja" versionDate="2019-06-08">
                           <p>
                              <val>I</val>，<val>M</val>，または<val>F</val>という値は，要素の再構成方法が明らかな場合にのみ使用する。</p>
                        </remarks>
                     </attDef>
                  </attList>
                  <remarks>
                     <p>The same as TEI's att.fragmentable, but turned into its own class
                     to make it global.</p>
                  </remarks>
               </classSpec>
               <!--lim.att.locatable-->
               <classSpec ident="lim.att.locatable" module="lim" type="atts" mode="add">
                  <classes>
                     <memberOf key="lim.att.locatable.directed"/>
                  </classes>
                  <attList>
                     <attDef ident="where" usage="opt">
                        <desc versionDate="2007-06-11" xml:lang="en">indicates the location of an event by pointing to a <gi>place</gi> element</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec>
               <!--lim.att.locatable.directed-->
               <classSpec ident="lim.att.locatable.directed"
                          module="lim"
                          type="atts"
                          mode="add">
                  <attList>
                     <attDef ident="toWhere" usage="opt">
                        <desc>indicates the location of something being sent.</desc>
                        <datatype>
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </classSpec>
               <!--lim.personMacro-->
               <macroSpec ident="lim.personMacro" module="lim" mode="add">
                  <content>
                     <elementRef key="persName" minOccurs="1" maxOccurs="unbounded"/>
                     <!--NOTE: preserveORder doesn't actually work, but there
                may be a new element coming: see
                https://github.com/TEIC/TEI/issues/2154 -->
                     <sequence preserveOrder="false">
                        <elementRef key="sex" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="birth" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="death" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="faith" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="affiliation" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="occupation" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="nationality" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="residence" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                     <!--Always make langKnowledge and note come last-->
                     <elementRef key="langKnowledge" minOccurs="0" maxOccurs="1"/>
                     <elementRef key="note" minOccurs="0" maxOccurs="1"/>
                  </content>
               </macroSpec>
               <!--limdata.ana-->
               <dataSpec module="lim" ident="limdata.ana" mode="add">
                  <desc>Datatype for all analytic pointers</desc>
                  <content>
                     <valList>
                        <valItem ident="lim:women">
                           <desc>women</desc>
                           <gloss>women</gloss>
                        </valItem>
                        <valItem ident="lim:gaelic">
                           <desc>gaelic</desc>
                           <gloss>gaelic</gloss>
                        </valItem>
                        <valItem ident="lim:media">
                           <desc>media</desc>
                           <gloss>media</gloss>
                        </valItem>
                        <valItem ident="lim:class">
                           <desc>class</desc>
                           <gloss>class</gloss>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec>
               <!--limdata.facs-->
               <dataSpec module="lim" ident="limdata.facs" mode="add">
                  <desc>Datatype for all lim facsimile pointers.</desc>
                  <content>
                     <dataRef name="token" restriction="(lib|pg):\d+(.\d+)?"/>
                  </content>
               </dataSpec>
               <!--limdata.glyph-->
               <dataSpec module="lim" ident="limdata.glyph" mode="add">
                  <desc>Datatype for all glyph pointers.</desc>
                  <content>
                     <valList type="closed">
                     </valList>
                  </content>
               </dataSpec>
               <!--limdata.placement-->
               <dataSpec module="lim" ident="limdata.placement" mode="add">
                  <desc>Possible values for placement.</desc>
                  <content>
                     <valList type="closed">
                        <valItem ident="bottom">
                           <gloss>bottom</gloss>
                           <desc>at the foot of the page</desc>
                        </valItem>
                        <valItem ident="left" mode="add">
                           <gloss>left</gloss>
                           <desc>in the left margin</desc>
                        </valItem>
                        <valItem ident="center" mode="add">
                           <gloss>center</gloss>
                           <desc>in the center</desc>
                        </valItem>
                        <valItem ident="right" mode="add">
                           <gloss>right</gloss>
                           <desc>in the right margin</desc>
                        </valItem>
                        <valItem ident="above" mode="add">
                           <gloss>above</gloss>
                           <desc>above the line</desc>
                        </valItem>
                        <valItem ident="below" mode="add">
                           <gloss>below</gloss>
                           <desc>below the line</desc>
                        </valItem>
                        <valItem ident="inline" mode="add">
                           <gloss>inline</gloss>
                           <desc>an inline note</desc>
                        </valItem>
                     </valList>
                  </content>
               </dataSpec>
               <!--fwPbConstraints-->
               <constraintSpec ident="fwPbConstraints"
                               module="lim"
                               mode="add"
                               scheme="schematron">
                  <desc>Set of constraints for formeworks and page beginnings.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:fw | tei:pb">
                           <sch:assert test="parent::tei:ab | parent::tei:back | parent::tei:body | parent::tei:div | parent::tei:front | parent::tei:list | parent::tei:p | parent::tei:text | parent::tei:q | parent::tei:note">
                              ERROR: <sch:name/> should not appear within <sch:value-of select="local-name(parent::*)"/>.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:fw">
                           <sch:assert test="not(tei:lb)">ERROR: <sch:name/> should not contain line beginnings 
                              (since they are usually a single line)</sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--global.rootIdMustMatchDocument-->
               <constraintSpec scheme="schematron" ident="global.rootIdMustMatchDocument">
                  <desc>The rootid must be the same as the document's name.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="/tei:*">
                           <sch:let name="rootEl" value="local-name()"/>
                           <sch:let name="correctDir" value="                     if (self::tei:person and @role='contributor') then 'contributors'                     else if (self::tei:person) then 'people'                     else if (self::tei:place) then 'places'                     else if (self::tei:org) then 'orgs'                     else $dirName"/>
                           <sch:assert test="$basename = $id">
                    ERROR: Document's @xml:id (<sch:value-of select="$id"/>) must match the document's base filename
                    (<sch:value-of select="$basename"/>)
                  </sch:assert>
                           <sch:assert test="$dirName = $correctDir">
                    ERROR: All <sch:value-of select="if (self::person/@role) then @role else local-name()"/> files should added to the <sch:value-of select="$correctDir"/> folder. This file (<sch:value-of select="$id"/>) is in the <sch:value-of select="$dirName"/> folder.
                  </sch:assert>
                           <!--<sch:rule context="/tei:person[not(@role='contributor')]">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All people should be added to the /people/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:person[@role='contributor']">
                    <sch:assert test="$dirName = 'people'">
                      ERROR: All contributors should be added to the /contributors/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:org">
                    <sch:assert test="$dirName = 'orgs'">
                      ERROR: All orgs should be added to the /orgs/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>
                  <sch:rule context="/tei:place">
                    <sch:assert test="$dirName = 'places'">
                      ERROR: All places should be added to the /places/ folder. This is in the <sch:value-of select="$dirName"/> folder.
                    </sch:assert>
                  </sch:rule>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--global.variables-->
               <constraintSpec scheme="schematron" ident="global.variables">
                  <desc>Global variables for use across the schematron.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:let name="id" value="/tei:*/@xml:id"/>
                        <sch:let name="uri" value="document-uri(/)"/>
                        <sch:let name="tokens" value="tokenize($uri,'[/\\]')"/>
                        <sch:let name="basename" value="replace($tokens[last()],'\.xm[l_]$','')"/>
                        <sch:let name="dirName" value="$tokens[last() - 1]"/>
                        <sch:let name="placeIdPattern" value="'[A-Z]{4}\d+'"/>
                        <sch:let name="orgIdPattern" value="'[A-Z]{4}\d+(_[^_]+)*'"/>
                        <sch:let name="persIdPattern" value="'[A-Z]{5}\d+'"/>
                        <sch:let name="cutoff" value="xs:date('1752-09-02')"/>
                        <sch:let name="root" value="root(.)"/>
                        <sch:let name="docStatus" value="//tei:revisionDesc/@docStatus"/>
                        <sch:let name="isBornDigital" value="exists($root//tei:catRef[matches(@target,'bornDigital')])"/>
                        <sch:let name="isItem" value="exists($root//tei:limItem)"/>
                        <!-- <sch:let name="pd" value="replace($uri,'^(.+[/\\]lim-tei[\\/]).+$', '$1')"/>
                <sch:let name="dataDir" value="replace($pd,'(.+(.))$','$1data$2')"/>
                <sch:let name="glyphs"
                  value="document($dataDir || 'glyphs.xml')//tei:glyph[@xml:id]"/> -->
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--inlineElementsNoSpaces-->
               <constraintSpec scheme="schematron" ident="inlineElementsNoSpaces">
                  <desc>Inline elements should not begin or end with spaces.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:title | tei:num | tei:ref | tei:rs | tei:placeName[not(parent::tei:place)] | tei:persName[not(parent::tei:person)]">
                           <sch:let name="text" value="string(.)"/>
                           <sch:assert test="not(matches($text, '^\s+|\s+$'))">
                    ERROR: <sch:name/> should not begin or end with spaces.
                  </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--metadataContraints-->
               <constraintSpec ident="metadataContraints"
                               module="lim"
                               mode="add"
                               scheme="schematron">
                  <desc>Set of constraints for profileDesc / premediation.</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:limItem">
                           <sch:let name="genre" value="@type"/>
                           <sch:assert test="if (matches($genre, 'letter','i')) then tei:correspDesc else true()">
                              ERROR: All letters must have a correspDesc.
                           </sch:assert>
                           <sch:assert test="if (matches($genre,'Speech|Account|Conversation','i')) then tei:settingDesc else true()">
                              ERROR: All <sch:value-of select="$genre"/> must have a settingDesc.
                           </sch:assert>
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
               <!--textConstraints-->
               <constraintSpec ident="textConstraints"
                               module="lim"
                               mode="add"
                               scheme="schematron">
                  <desc>Set of constraints for text and punctuation</desc>
                  <constraint>
                     <sch:pattern>
                        <sch:rule context="tei:*[text()][matches(string-join(text(),''),'\S')][ancestor::tei:text][$docStatus=('draft','inProgress','proofed', 'readyForProof')]">
                           <sch:let name="string" value="string-join(text(),'')"/>
                           <sch:assert test="not(matches($string,'(--+)|(––+)'))">
                              ERROR: Do not use multiple hyphens or en-dashes to represent an em-dash (—).
                           </sch:assert>
                          <!-- <sch:assert test="not(matches(., $sq)) and not(ancestor::tei:code | ancestor::*:egXML)">
                              ERROR: Straight quotation marks should be replaced by curly ones
                           </sch:assert>-->
                        </sch:rule>
                     </sch:pattern>
                  </constraint>
               </constraintSpec>
            </schemaSpec>
         </div>
      </body>
   </text>
</TEI>
